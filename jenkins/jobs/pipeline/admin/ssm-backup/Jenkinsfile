@Library('jenkins-shared-lib') _

def regionList = []
def regionSummaries = [:]
def pipelineContext = [
    metadataBasePath: "/jenkins/${params.ENVIRONMENT}/backup",
]

node('ec2-fleet') {
    timestamps {
        def ssmHomeRegion = env.SSM_HOME_REGION ?: 'ap-northeast-1'
        def workDirRelative = "backup-work"
        def dataDirRelative = "${workDirRelative}/data"
        def scriptDirRelative = "${workDirRelative}/scripts"
        def workDir = "${env.WORKSPACE}/${workDirRelative}"
        def dataDir = "${env.WORKSPACE}/${dataDirRelative}"
        def scriptDir = "${env.WORKSPACE}/${scriptDirRelative}"
        def envFilter = "/${params.ENVIRONMENT}/"
        env.SSM_HOME_REGION = ssmHomeRegion
        env.WORK_DIR = workDir
        env.DATA_DIR = dataDir
        env.SCRIPT_DIR = scriptDir
        env.ENV_FILTER = envFilter

        try {
            stage('Initialize') {
                env.BACKUP_DATE = sh(script: "date '+%Y-%m-%d'", returnStdout: true).trim()
                env.BACKUP_TIMESTAMP = sh(script: "date '+%Y%m%d_%H%M%S'", returnStdout: true).trim()

                sh """
                    rm -rf ${workDir}
                    mkdir -p ${dataDir}
                    mkdir -p ${scriptDir}
                """

                def regionListJson = sh(
                    script: """
                        aws ssm get-parameter \\
                            --name "${pipelineContext.metadataBasePath}/region-list" \\
                            --query 'Parameter.Value' \\
                            --output text \\
                            --region ${ssmHomeRegion} 2>/dev/null || echo ""
                    """,
                    returnStdout: true
                ).trim()

                if (!regionListJson?.trim()) {
                    error("Region list parameter '${pipelineContext.metadataBasePath}/region-list' is missing or empty.")
                }

                regionList = readJSON(text: regionListJson)
                if (!(regionList instanceof List) || regionList.isEmpty()) {
                    error("Region list is empty. Pulumi config must define at least one region.")
                }

                regionList = regionList.collect { it.toString() }

                def defaultRegionValue = sh(
                    script: """
                        aws ssm get-parameter \\
                            --name "${pipelineContext.metadataBasePath}/default-region" \\
                            --query 'Parameter.Value' \\
                            --output text \\
                            --region ${ssmHomeRegion} 2>/dev/null || echo ""
                    """,
                    returnStdout: true
                ).trim()

                if (!defaultRegionValue) {
                    error("Default region parameter '${pipelineContext.metadataBasePath}/default-region' is missing.")
                }

                if (!regionList.contains(defaultRegionValue)) {
                    error("Default region '${defaultRegionValue}' is not part of configured region list ${regionList}.")
                }

                env.DEFAULT_REGION = defaultRegionValue

                def legacyBucket = sh(
                    script: """
                        aws ssm get-parameter \\
                            --name "${pipelineContext.metadataBasePath}/s3-bucket-name" \\
                            --query 'Parameter.Value' \\
                            --output text \\
                            --region ${ssmHomeRegion} 2>/dev/null || echo ""
                    """,
                    returnStdout: true
                ).trim()

                if (legacyBucket) {
                    env.BACKUP_BUCKET = legacyBucket
                }

                currentBuild.displayName = "#${env.BUILD_NUMBER} - ${params.ENVIRONMENT} Backup"
                currentBuild.description = "Regions=${regionList.join(',')} | Default=${defaultRegionValue}"

                echo """
                =============================================
                SSM Parameter Store Backup (Multi-Region)
                =============================================
                Environment      : ${params.ENVIRONMENT}
                Regions          : ${regionList.join(', ')}
                Default Region   : ${defaultRegionValue}
                Dry Run          : ${params.DRY_RUN}
                Backup Date      : ${env.BACKUP_DATE}
                Timestamp        : ${env.BACKUP_TIMESTAMP}
                SSM Home Region  : ${ssmHomeRegion}
                Work Directory   : ${workDir}
                =============================================
                """.stripIndent()

                env.REGION_LIST = regionList.join(',')
                pipelineContext.timeoutMinutes = Math.max(regionList.size() * 10 + 30, 30)
            }

            timeout(time: pipelineContext.timeoutMinutes as int, unit: 'MINUTES') {
                stage('Prepare Scripts') {
                    sh "rm -rf jenkins-repo"
                    dir('jenkins-repo') {
                        checkout([
                            $class: 'GitSCM',
                            branches: [[name: "${params.JENKINSFILE_BRANCH}"]],
                            userRemoteConfigs: [[
                                url: 'https://github.com/tielec/infrastructure-as-code',
                                credentialsId: 'github-app-credentials'
                            ]]
                        ])
                    }

                    sh """
                        cp jenkins-repo/jenkins/jobs/pipeline/admin/ssm-backup/scripts/collect_parameters.sh ${scriptDir}/
                        chmod +x ${scriptDir}/collect_parameters.sh
                        ls -la ${scriptDir}/
                    """
                }

                boolean dryRun = params.DRY_RUN as boolean

                regionList.each { region ->
                    stage("Backup ${region}") {
                        def ctx = loadRegionContext(
                            params.ENVIRONMENT,
                            region,
                            pipelineContext.metadataBasePath,
                            ssmHomeRegion,
                            dataDir
                        )

                        def stageStart = System.currentTimeMillis()

                        try {
                            def result = runBackupForRegion(
                                ctx + [
                                    defaultRegion: env.DEFAULT_REGION,
                                    scriptDir: scriptDir,
                                    envFilter: env.ENV_FILTER,
                                    backupDate: env.BACKUP_DATE,
                                    backupTimestamp: env.BACKUP_TIMESTAMP,
                                ],
                                dryRun
                            )

                            def durationSeconds = ((System.currentTimeMillis() - stageStart) / 1000) as long

                            regionSummaries[region] = [
                                status          : 'SUCCESS',
                                parameterCount  : result.parameterCount,
                                bucket          : ctx.bucketName,
                                s3Key           : result.s3Key,
                                dryRun          : dryRun,
                                durationSeconds : durationSeconds,
                                executionTimeSec: result.executionTimeSec,
                                failedCount     : result.failedCount,
                            ]

                            echo "Backup for ${region} completed (parameters=${result.parameterCount}, dryRun=${dryRun})"
                        } catch (Throwable t) {
                            def durationSeconds = ((System.currentTimeMillis() - stageStart) / 1000) as long
                            regionSummaries[region] = [
                                status          : 'FAILED',
                                message         : t.getMessage(),
                                durationSeconds : durationSeconds,
                            ]
                            throw t
                        }
                    }
                }

                stage('Finalize Report') {
                    def summaryFile = "${workDirRelative}/region_summaries.json"
                    writeJSON file: summaryFile, json: regionSummaries, pretty: 4
                    archiveArtifacts artifacts: summaryFile, fingerprint: true
                    env.REGION_SUMMARY_PATH = "${workDir}/${summaryFile.split('/', 2).last()}"
                    echo "Region summary stored at ${summaryFile}"
                }
            }

            currentBuild.result = currentBuild.result ?: 'SUCCESS'
        } catch (Throwable err) {
            currentBuild.result = currentBuild.result ?: 'FAILURE'
            throw err
        } finally {
            stage('Post Actions') {
                emitRunSummary(regionSummaries, params.ENVIRONMENT, params.DRY_RUN as boolean)
                try {
                    notifyChannels(regionSummaries, params.ENVIRONMENT, params.DRY_RUN as boolean)
                } catch (Throwable notificationError) {
                    echo "Failed to send notifications: ${notificationError.getMessage() ?: notificationError.toString()}"
                }
                if (currentBuild.result == 'SUCCESS') {
                    echo "✅ SSMパラメータのバックアップが正常に完了しました"
                } else if (currentBuild.result == 'UNSTABLE') {
                    echo "⚠️ バックアップは完了しましたが、警告があります"
                } else {
                    echo "❌ バックアップが失敗しました。ログを確認してください"
                }

                sh "rm -rf ${workDir} jenkins-repo || true"
            }
        }
    }
}

def loadRegionContext(String environment, String region, String metadataBasePath, String ssmHomeRegion, String dataDirRoot) {
    def parameterName = "${metadataBasePath}/${region}/s3-bucket-name"
    def bucketName = sh(
        script: """
            aws ssm get-parameter \\
                --name "${parameterName}" \\
                --query 'Parameter.Value' \\
                --output text \\
                --region ${ssmHomeRegion} 2>/dev/null || echo ""
        """,
        returnStdout: true
    ).trim()

    if (!bucketName) {
        error("Bucket definition missing for region ${region}. Expected SSM parameter ${parameterName}.")
    }

    def regionDataDir = "${dataDirRoot}/${region}"
    sh """
        rm -rf ${regionDataDir}
        mkdir -p ${regionDataDir}
    """

    return [
        environment   : environment,
        region        : region,
        bucketName    : bucketName,
        regionDataDir : regionDataDir,
    ]
}

def runBackupForRegion(Map ctx, boolean dryRun) {
    def envFilter = ctx.envFilter
    def scriptDir = ctx.scriptDir
    def backupDate = ctx.backupDate
    def backupTimestamp = ctx.backupTimestamp
    def environment = ctx.environment
    def region = ctx.region
    def regionDataDir = ctx.regionDataDir
    def bucketName = ctx.bucketName
    def defaultRegion = ctx.defaultRegion

    def backupJsonPath = "${regionDataDir}/backup.json"
    def backupFileName = "ssm-backup-${environment}-${region}-${backupTimestamp}.json"
    def backupFilePath = "${regionDataDir}/${backupFileName}"
    def s3Key = "${backupDate}/${region}/${backupFileName}"

    withEnv([
        "ENVIRONMENT=${environment}",
        "ENV_FILTER=${envFilter}",
        "AWS_REGION=${region}",
        "BACKUP_DATE=${backupDate}",
        "BACKUP_TIMESTAMP=${backupTimestamp}",
        "DATA_DIR=${regionDataDir}",
        "TARGET_REGION=${region}",
    ]) {
        sh """
            rm -f ${regionDataDir}/*
            ${scriptDir}/collect_parameters.sh
        """
    }

    if (!fileExists(backupJsonPath)) {
        error("Backup file was not created for region ${region}.")
    }

    sh "cp ${backupJsonPath} ${backupFilePath}"

    def backupData = readJSON file: backupJsonPath
    def parameterCount = (backupData.parameter_count ?: backupData.parameterCount ?: 0) as int

    def summaryPath = "${regionDataDir}/summary.json"
    def scriptSummary = [:]
    if (fileExists(summaryPath)) {
        scriptSummary = readJSON file: summaryPath
    }
    def mergedSummary = [:]
    mergedSummary << (scriptSummary ?: [:])
    mergedSummary << [
        region         : region,
        parameterCount : parameterCount,
        s3Key          : s3Key,
        dryRun         : dryRun,
        bucket         : bucketName,
    ]
    writeJSON file: summaryPath, json: mergedSummary, pretty: 4

    if (!dryRun && parameterCount > 0) {
        sh """
            aws s3 cp ${backupFilePath} \
                s3://${bucketName}/${s3Key} \
                --sse AES256 \
                --region ${region}
        """

        sh """
            echo '${s3Key}' | aws s3 cp - s3://${bucketName}/latest-${region}.txt \
                --sse AES256 \
                --region ${region}
        """

        if (region == defaultRegion) {
            sh """
                echo '${s3Key}' | aws s3 cp - s3://${bucketName}/latest.txt \
                    --sse AES256 \
                    --region ${region}
            """
        }

        def objectInfo = sh(
            script: """
                aws s3api head-object \\
                    --bucket ${bucketName} \\
                    --key ${s3Key} \\
                    --query '[ContentLength, LastModified]' \\
                    --output text \\
                    --region ${region}
            """,
            returnStdout: true
        ).trim()

        echo "S3 Object Info [${region}]: ${objectInfo}"
    } else if (dryRun) {
        echo "[DRY RUN] Skipped S3 upload for ${region}. Planned key: ${s3Key}"
    } else {
        echo "No parameters to upload for ${region}. Skipping S3 upload."
    }

    def executionTimeSec = mergedSummary.executionTimeSec != null ? (mergedSummary.executionTimeSec as long) : null
    def failedCount = mergedSummary.failedCount != null ? (mergedSummary.failedCount as long) : null

    return [
        parameterCount : parameterCount,
        s3Key          : s3Key,
        backupFilePath : backupFilePath,
        summaryPath    : summaryPath,
        executionTimeSec: executionTimeSec,
        failedCount     : failedCount,
    ]
}

def emitRunSummary(Map regionSummaries, String environment, boolean dryRun) {
    echo """
    =============================================
    SSM Parameter Store Backup Summary
    =============================================
    Build       : #${env.BUILD_NUMBER}
    Status      : ${currentBuild.result ?: 'UNKNOWN'}
    Environment : ${environment}
    Dry Run     : ${dryRun}
    Regions     : ${env.REGION_LIST ?: 'N/A'}
    Summary File: ${env.REGION_SUMMARY_PATH ?: 'N/A'}
    =============================================
    """.stripIndent()

    regionSummaries.each { region, summary ->
        echo "Region: ${region} => ${summary}"
    }
}

def notifyChannels(Map regionSummaries, String environment, boolean dryRun) {
    def result = currentBuild.result ?: 'UNKNOWN'
    def runbookUrl = 'https://github.com/tielec/infrastructure-as-code/blob/main/docs/runbooks/ssm-backup.md'
    def buildUrl = env.BUILD_URL ?: ''
    def summaryArtifact = env.REGION_SUMMARY_PATH ?: 'N/A'
    def totalRegions = regionSummaries?.size() ?: 0
    def successCount = regionSummaries.findAll { it.value?.status == 'SUCCESS' }.size()
    def failureCount = Math.max(totalRegions - successCount, 0)
    def summaryLines = formatRegionSummaryLines(regionSummaries)
    def slackColor = (result == 'SUCCESS') ? 'good' : ((result == 'UNSTABLE') ? 'warning' : 'danger')
    def slackMessage = """*Result*: ${result}
*Environment*: ${environment}
*Dry Run*: ${dryRun}
*Regions*: ${totalRegions} total / ${successCount} success / ${failureCount} failed
*Summary Artifact*: ${summaryArtifact}
${summaryLines ?: 'No regional data recorded.'}
Runbook: ${runbookUrl}
${buildUrl ? "Build: ${buildUrl}" : ''}"""

    try {
        slackSend(
            channel: '#infra-backup-alerts',
            attachments: [[
                color     : slackColor,
                title     : "SSM Backup ${environment} #${env.BUILD_NUMBER}",
                text      : slackMessage,
                mrkdwn_in : ['text', 'pretext'],
            ]]
        )
    } catch (Throwable slackErr) {
        echo "Slack notification failed: ${slackErr.getMessage() ?: slackErr.toString()}"
    }

    def emailSubjectPrefix = (result == 'FAILURE') ? '[FAIL]' : "[${result}]"
    def dryRunSuffix = dryRun ? ' (DRY RUN)' : ''
    def emailSubject = "[SSM Backup] ${emailSubjectPrefix} ${environment} #${env.BUILD_NUMBER}${dryRunSuffix}"
    def summaryBlock = summaryLines ?: 'No regional data recorded.'
    def escapedSummaryBlock = escapeHtml(summaryBlock)
    def escapedSummaryArtifact = escapeHtml(summaryArtifact)
    def emailBody = """<p>SSM Parameter Store backup for <strong>${environment}</strong> finished with result <strong>${result}</strong>.</p>
<p>Dry Run: <strong>${dryRun}</strong><br/>
Regions: <strong>${totalRegions}</strong> total / <strong>${successCount}</strong> success / <strong>${failureCount}</strong> failed</p>
<p><pre>${escapedSummaryBlock}</pre></p>
<p>Region summary artifact: ${escapedSummaryArtifact}</p>
<p><a href="${runbookUrl}">Runbook</a>${buildUrl ? " | <a href=\\"${buildUrl}\\">Build Logs</a>" : ''}</p>"""

    def emailTo = 'ops-alerts@example.com'
    def emailCc = (result == 'FAILURE') ? 'sre-oncall@example.com' : ''

    try {
        emailext(
            to: emailTo,
            cc: emailCc,
            subject: emailSubject,
            mimeType: 'text/html',
            body: emailBody
        )
    } catch (Throwable emailErr) {
        echo "Email notification failed: ${emailErr.getMessage() ?: emailErr.toString()}"
    }
}

def formatRegionSummaryLines(Map regionSummaries) {
    if (!regionSummaries || regionSummaries.isEmpty()) {
        return ''
    }

    def lines = []
    regionSummaries.keySet().sort().each { region ->
        def summary = regionSummaries[region] ?: [:]
        def fragments = []
        fragments << (summary.status ?: 'UNKNOWN')
        if (summary.parameterCount != null) {
            fragments << "count=${summary.parameterCount}"
        }
        if (summary.failedCount) {
            fragments << "failed=${summary.failedCount}"
        }
        if (summary.durationSeconds != null) {
            fragments << "stage=${summary.durationSeconds}s"
        }
        if (summary.executionTimeSec != null) {
            fragments << "script=${summary.executionTimeSec}s"
        }
        if (summary.s3Key) {
            fragments << "s3=${summary.s3Key}"
        }
        if (summary.message) {
            fragments << "message=${summary.message}"
        }
        lines << "${region}: ${fragments.join(', ')}"
    }

    return lines.join('\n')
}

def escapeHtml(String value) {
    if (!value) {
        return ''
    }

    value
        .replace('&', '&amp;')
        .replace('<', '&lt;')
        .replace('>', '&gt;')
        .replace('"', '&quot;')
        .replace("'", '&#39;')
}
