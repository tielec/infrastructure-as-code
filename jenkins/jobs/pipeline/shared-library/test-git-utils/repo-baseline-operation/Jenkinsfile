@Library('jenkins-shared-lib') _

// ãƒªãƒã‚¸ãƒˆãƒªãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³æ©Ÿèƒ½ã®çµ±åˆãƒ†ã‚¹ãƒˆç”¨ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
pipeline {
    agent { label params.AGENT_LABEL ?: 'ec2-fleet-micro' }
    options {
        ansiColor('xterm')
        skipDefaultCheckout()
        timestamps()
    }

    parameters {
        choice(name: 'AGENT_LABEL', choices: ['ec2-fleet-micro', 'ec2-fleet-small', 'ec2-fleet-medium'], description: 'Jenkinsã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ãƒ©ãƒ™ãƒ«')
        choice(name: 'TEST_TYPE', choices: ['ALL', 'RULESETS', 'BRANCH_PROTECTION', 'SECURITY', 'LABELS', 'FACADE', 'PIPELINE', 'ERROR', 'IDEMPOTENT'], description: 'å®Ÿè¡Œã™ã‚‹ãƒ†ã‚¹ãƒˆã‚«ãƒ†ã‚´ãƒª')
        choice(name: 'TEMPLATE', choices: ['default', 'strict', 'minimal'], description: 'ä½¿ç”¨ã™ã‚‹ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ')
        choice(name: 'ACTION', choices: ['DRY_RUN', 'APPLY'], description: 'ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³é©ç”¨ã®å‹•ä½œãƒ¢ãƒ¼ãƒ‰')
        string(name: 'REPO_URL', defaultValue: 'https://github.com/tielec/infrastructure-as-code', description: 'ãƒ†ã‚¹ãƒˆå¯¾è±¡ã®GitHubãƒªãƒã‚¸ãƒˆãƒªURLï¼ˆå˜ä¸€ï¼‰')
        string(name: 'ADDITIONAL_REPOS', defaultValue: '', description: 'è¿½åŠ ã§ãƒ†ã‚¹ãƒˆã™ã‚‹ãƒªãƒã‚¸ãƒˆãƒªã®owner/nameã‚’ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã§æŒ‡å®šï¼ˆè¤‡æ•°ãƒªãƒã‚¸ãƒˆãƒªå·®åˆ†æ¤œè¨¼ç”¨ï¼‰')
        string(name: 'TARGET_BRANCH', defaultValue: '', description: 'ãƒ–ãƒ©ãƒ³ãƒä¿è­·å¯¾è±¡ï¼ˆæœªæŒ‡å®šã®å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ–ãƒ©ãƒ³ãƒï¼‰')
        booleanParam(name: 'CLEANUP_AFTER_TEST', defaultValue: true, description: 'ãƒ†ã‚¹ãƒˆå¾Œã«ä½œæˆã—ãŸãƒªã‚½ãƒ¼ã‚¹ã‚’å‰Šé™¤ã™ã‚‹')
        string(name: 'RATE_LIMIT_THRESHOLD', defaultValue: '10', description: 'Rate Limitæ®‹é‡ãŒã“ã®å€¤æœªæº€ãªã‚‰å¾…æ©Ÿã—ã¦ã‹ã‚‰å†é–‹ï¼ˆINT-ERROR-004ç”¨ï¼‰')
        booleanParam(name: 'FORCE_RATE_LIMIT_WAIT', defaultValue: false, description: 'Rate Limitå¾…æ©Ÿã‚’å¼·åˆ¶ç™ºç«ã•ã›ã‚‹ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒƒãƒ')
        string(name: 'JENKINSFILE_BRANCH', defaultValue: 'main', description: 'ã“ã®Jenkinsfileã‚’å–å¾—ã™ã‚‹ãƒ–ãƒ©ãƒ³ãƒ')
    }

    environment {
        BASELINE_CONFIG_JSON = ''
        TEST_LABEL_NAME = ''
        TEST_RULESET_ID = ''
        TARGET_BRANCH_NAME = ''
        ADDITIONAL_REPO_JSON = '[]'
    }

    stages {
        stage('Setup') {
            steps {
                script {
                    echo "=== Repo Baseline Integration Test ==="
                    if (!params.REPO_URL?.trim()) {
                        error 'REPO_URLã¯å¿…é ˆã§ã™'
                    }

                    def repoInfo = gitUtils.extractRepoInfo(params.REPO_URL)
                    env.REPO_OWNER = repoInfo[0]
                    env.REPO_NAME = repoInfo[1]
                    echo "Repository: ${env.REPO_OWNER}/${env.REPO_NAME}"

                    env.ADDITIONAL_REPO_JSON = writeJSON(returnText: true, json: parseAdditionalRepos(params.ADDITIONAL_REPOS))
                    echo "Additional Repos: ${env.ADDITIONAL_REPO_JSON}"

                    def connectionTest = gitUtils.testGitHubAppConnection()
                    if (!connectionTest.success) {
                        error "GitHubæ¥ç¶šãƒ†ã‚¹ãƒˆã«å¤±æ•—: ${connectionTest.message}"
                    }
                    echo "Rate Limit: ${connectionTest.rate_limit.remaining}/${connectionTest.rate_limit.limit}"

                    def baselineFile = readYaml file: 'jenkins/jobs/pipeline/admin/github-repo-baseline/config/baseline-config.yaml'
                    def template = baselineFile.templates[params.TEMPLATE]
                    if (!template) {
                        error "ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ ${params.TEMPLATE} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"
                    }
                    env.BASELINE_CONFIG_JSON = writeJSON(returnText: true, json: template)

                    def repoCfg = baseRepoConfig()
                    def defaultBranch = gitUtils.getDefaultBranch(repoCfg)
                    env.TARGET_BRANCH_NAME = params.TARGET_BRANCH?.trim() ? params.TARGET_BRANCH.trim() : defaultBranch

                    echo "Default Branch: ${defaultBranch} / Target Branch: ${env.TARGET_BRANCH_NAME}"
                    echo "Action: ${params.ACTION}, TestType: ${params.TEST_TYPE}, Template: ${params.TEMPLATE}"

                    // ãƒ†ã‚¹ãƒˆå°‚ç”¨ãƒªã‚½ãƒ¼ã‚¹åã‚’ç”Ÿæˆ
                    env.TEST_LABEL_NAME = "baseline-it-label-${env.BUILD_ID}"
                }
            }
        }

        stage('Rate Limit Guard') {
            when { expression { shouldRun('ERROR') || params.FORCE_RATE_LIMIT_WAIT } }
            steps {
                script {
                    // INT-ERROR-004: Rate Limitåˆ°é”æ™‚ã«ä¸€æ™‚åœæ­¢ã—ã€ãƒªã‚»ãƒƒãƒˆå¾Œã«å†é–‹ã§ãã‚‹ã“ã¨ã‚’æ¤œè¨¼
                    def threshold = (params.RATE_LIMIT_THRESHOLD ?: '0') as Integer
                    def status = gitUtils.testGitHubAppConnection()
                    def remaining = status.rate_limit.remaining as Integer
                    def limit = status.rate_limit.limit as Integer
                    def resetAt = (status.rate_limit.reset ?: 0) as Long
                    if (params.FORCE_RATE_LIMIT_WAIT || remaining < threshold) {
                        def nowSec = (System.currentTimeMillis() / 1000L) as Long
                        def waitSeconds = Math.max(resetAt - nowSec, 0) + 5
                        echo "â³ Rate Limitæ®‹é‡ ${remaining}/${limit} (<${threshold}) ã®ãŸã‚ ${waitSeconds}s å¾…æ©Ÿã—ã¦ã‹ã‚‰å†é–‹"
                        sleep time: waitSeconds, unit: 'SECONDS'
                        def after = gitUtils.testGitHubAppConnection()
                        echo "å†é–‹å¾Œã®æ®‹é‡: ${after.rate_limit.remaining}/${after.rate_limit.limit}"
                    } else {
                        echo "Rate Limitæ®‹é‡ååˆ†: ${remaining}/${limit}; å¾…æ©Ÿä¸è¦"
                    }
                }
            }
        }

        stage('Ruleset Tests') {
            when { expression { shouldRun('RULESETS') } }
            steps {
                script {
                    def cfg = baseRepoConfig()
                    def baseline = loadBaseline()
                    def rulesets = baseline.rulesets ?: []
                    def createdRuleId = ''

                    echo "æ—¢å­˜Rulesetä»¶æ•°: ${gitUtils.listRulesets(cfg)?.size() ?: 0}"

                    if (params.ACTION == 'DRY_RUN') {
                        def diff = gitUtils.generateBaselineDiff(baseline, cfg)
                        echo "[DRY_RUN] ä½œæˆäºˆå®š: ${diff.rulesets.toCreate}, æ›´æ–°äºˆå®š: ${diff.rulesets.toUpdate.collect{it.name}}"
                        return
                    }

                    try {
                        if (rulesets) {
                            def testRule = cloneMap(rulesets[0])
                            testRule.name = "${testRule.name}-it-${env.BUILD_ID}"

                            def created = gitUtils.createRuleset(testRule, cfg)
                            createdRuleId = created.id as String
                            env.TEST_RULESET_ID = createdRuleId
                            echo "âœ… ãƒ«ãƒ¼ãƒ«ã‚»ãƒƒãƒˆä½œæˆ: ${created.name} (${created.id})"

                            def fetched = gitUtils.getRuleset(created.id, cfg)
                            echo "å–å¾—ç¢ºèª(Givenâ†’Whenâ†’Then): enforcement=${fetched.enforcement}"

                            def updated = gitUtils.updateRuleset(created.id, testRule + [enforcement: 'evaluate'], cfg)
                            echo "æ›´æ–°ç¢ºèª(Then): enforcement=${updated.enforcement}"
                        } else {
                            echo "âš ï¸ ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã«rulesetsãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„ãŸã‚ã‚¹ã‚­ãƒƒãƒ—"
                        }
                    } finally {
                        if (params.CLEANUP_AFTER_TEST && createdRuleId) {
                            gitUtils.deleteRuleset(createdRuleId, cfg)
                            echo "ğŸ§¹ ãƒ†ã‚¹ãƒˆã§ä½œæˆã—ãŸãƒ«ãƒ¼ãƒ«ã‚»ãƒƒãƒˆã‚’å‰Šé™¤ (${createdRuleId})"
                        }
                    }
                }
            }
        }

        stage('Branch Protection Tests') {
            when { expression { shouldRun('BRANCH_PROTECTION') } }
            steps {
                script {
                    def cfg = baseRepoConfig()
                    def baseline = loadBaseline()
                    def protectionData = baseline.branchProtection?.settings ?: baseline.branchProtection

                    def current = gitUtils.getBranchProtection(env.TARGET_BRANCH_NAME, cfg)
                    echo "ç¾åœ¨ã®ä¿è­·çŠ¶æ…‹ (Given): ${current ? 'è¨­å®šã‚ã‚Š' : 'æœªè¨­å®š'}"

                    if (params.ACTION == 'DRY_RUN') {
                        echo "[DRY_RUN] ãƒ–ãƒ©ãƒ³ãƒä¿è­·ã‚’é©ç”¨äºˆå®š (${env.TARGET_BRANCH_NAME})"
                        return
                    }

                    gitUtils.updateBranchProtection(env.TARGET_BRANCH_NAME, protectionData, cfg)
                    def after = gitUtils.getBranchProtection(env.TARGET_BRANCH_NAME, cfg)
                    echo "âœ… ãƒ–ãƒ©ãƒ³ãƒä¿è­·é©ç”¨å¾Œ (Then): reviews=${after.required_pull_request_reviews?.required_approving_review_count ?: 'N/A'}"

                    if (params.CLEANUP_AFTER_TEST && current == null) {
                        gitUtils.deleteBranchProtection(env.TARGET_BRANCH_NAME, cfg)
                        echo "ğŸ§¹ ãƒ†ã‚¹ãƒˆã§è¿½åŠ ã—ãŸãƒ–ãƒ©ãƒ³ãƒä¿è­·ã‚’å‰Šé™¤"
                    }
                }
            }
        }

        stage('Security Tests') {
            when { expression { shouldRun('SECURITY') } }
            steps {
                script {
                    def cfg = baseRepoConfig()
                    def before = gitUtils.getSecuritySettings(cfg)
                    echo "ç¾åœ¨ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£: dependabot=${before.dependabotAlerts}, secret_scanning=${before.secretScanning}"

                    if (params.ACTION == 'DRY_RUN') {
                        echo "[DRY_RUN] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æœ‰åŠ¹åŒ–ã‚’æ¤œè¨¼"
                        return
                    }

                    gitUtils.enableDependabotAlerts(cfg)
                    gitUtils.enableDependabotSecurityUpdates(cfg)
                    gitUtils.enableSecretScanning(cfg)

                    def after = gitUtils.getSecuritySettings(cfg)
                    echo "âœ… ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æœ‰åŠ¹åŒ–å¾Œ: dependabot=${after.dependabotAlerts}, secret_scanning=${after.secretScanning}"
                }
            }
        }

        stage('Label Tests') {
            when { expression { shouldRun('LABELS') } }
            steps {
                script {
                    def cfg = baseRepoConfig()
                    def baseline = loadBaseline()

                    def labels = gitUtils.listLabels(cfg)
                    echo "æ—¢å­˜ãƒ©ãƒ™ãƒ«æ•°: ${labels?.size() ?: 0}"

                    if (params.ACTION == 'DRY_RUN') {
                        echo "[DRY_RUN] ãƒ©ãƒ™ãƒ«åŒæœŸäºˆå®š: ${baseline.labels?.size() ?: 0}ä»¶"
                        return
                    }

                    // ãƒ©ãƒ™ãƒ«ä½œæˆ
                    def created = gitUtils.createLabel([
                        name: env.TEST_LABEL_NAME,
                        color: '0e8a16',
                        description: 'integration test label'
                    ], cfg)
                    echo "âœ… ãƒ©ãƒ™ãƒ«ä½œæˆ: ${created.name} (${created.color})"

                    // ãƒ©ãƒ™ãƒ«æ›´æ–°
                    def updated = gitUtils.updateLabel(env.TEST_LABEL_NAME, [color: 'b60205', description: 'updated by integration test'], cfg)
                    echo "æ›´æ–°å¾Œ: color=${updated.color}"

                    // ãƒ©ãƒ™ãƒ«åŒæœŸï¼ˆåŸºæº–è¨­å®šã«åˆã‚ã›ã‚‹ï¼‰
                    def syncResult = gitUtils.syncLabels(baseline.labels, cfg)
                    echo "åŒæœŸçµæœ: ä½œæˆ=${syncResult.count { it.action == 'created' }}, æ›´æ–°=${syncResult.count { it.action == 'updated' }}"

                    if (params.CLEANUP_AFTER_TEST) {
                        gitUtils.deleteLabel(env.TEST_LABEL_NAME, cfg)
                        echo "ğŸ§¹ ãƒ†ã‚¹ãƒˆç”¨ãƒ©ãƒ™ãƒ«ã‚’å‰Šé™¤"
                    }
                }
            }
        }

        stage('Facade Tests') {
            when { expression { shouldRun('FACADE') } }
            steps {
                script {
                    def cfg = baseRepoConfig()
                    def baseline = loadBaseline()
                    def repoList = [[owner: env.REPO_OWNER, name: env.REPO_NAME]] + parseAdditionalRepos(env.ADDITIONAL_REPO_JSON)

                    def status = gitUtils.getRepoBaselineStatus(baseline, cfg)
                    echo "ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: rulesets=${status.rulesets}, branch=${status.branchProtection?.status}"

                    def diff = gitUtils.generateBaselineDiff(baseline, cfg)
                    echo "å·®åˆ†: toCreate=${diff.rulesets.toCreate}, toUpdate=${diff.rulesets.toUpdate.collect{it.name}}"

                    def applyResult = gitUtils.applyRepoBaseline(baseline, cfg + [dryRun: params.ACTION == 'DRY_RUN'])
                    echo "é©ç”¨çµæœ(dryRun=${applyResult.dryRun}): rulesets=${applyResult.rulesets.size()}, labels=${applyResult.labels.size()}"

                    def batchResult = gitUtils.batchApplyRepoBaseline(repoList, baseline, cfg + [dryRun: true])
                    echo "ãƒãƒƒãƒé©ç”¨(ãƒ‰ãƒ©ã‚¤ãƒ©ãƒ³)çµæœä»¶æ•°: ${batchResult.size()} / å¯¾è±¡ãƒªãƒã‚¸ãƒˆãƒª: ${repoList}"
                }
            }
        }

        stage('Pipeline Smoke') {
            when { expression { shouldRun('PIPELINE') } }
            steps {
                script {
                    def cfg = baseRepoConfig()
                    def baseline = loadBaseline()
                    def filtered = filterBaselineForSmoke(baseline)

                    def result = gitUtils.applyRepoBaseline(filtered, cfg + [dryRun: params.ACTION == 'DRY_RUN'])
                    echo "ã‚¹ãƒ¢ãƒ¼ã‚¯é©ç”¨å®Œäº†: rulesets=${result.rulesets.size()}, branch=${result.branchProtection?.action ?: 'none'}"
                }
            }
        }

        stage('Error Handling') {
            when { expression { shouldRun('ERROR') } }
            steps {
                script {
                    def cfg = [repoOwner: 'invalid', repoName: 'repo']
                    try {
                        gitUtils.listRulesets(cfg)
                        error 'æƒ³å®šå¤–: ç„¡åŠ¹ãƒªãƒã‚¸ãƒˆãƒªã§ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã›ã‚“ã§ã—ãŸ'
                    } catch (Exception e) {
                        echo "âœ… ç„¡åŠ¹ãƒªãƒã‚¸ãƒˆãƒªã§ä¾‹å¤–ã‚’æ¤œçŸ¥: ${e.message}"
                    }
                }
            }
        }

        stage('Idempotent Check') {
            when { expression { shouldRun('IDEMPOTENT') } }
            steps {
                script {
                    def cfg = baseRepoConfig()
                    def baseline = loadBaseline()
                    def first = gitUtils.applyRepoBaseline(baseline, cfg + [dryRun: params.ACTION == 'DRY_RUN'])
                    def second = gitUtils.applyRepoBaseline(baseline, cfg + [dryRun: params.ACTION == 'DRY_RUN'])

                    if (first.toString() == second.toString()) {
                        echo 'âœ… 2å›ç›®ã®å®Ÿè¡Œã§ã‚‚å·®åˆ†ãªã—ï¼ˆå†ªç­‰æ€§ç¢ºèªï¼‰'
                    } else {
                        echo 'âš ï¸ å†ªç­‰æ€§ã«å·®åˆ†ã‚’æ¤œçŸ¥'
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                echo "=== ãƒ†ã‚¹ãƒˆã‚µãƒãƒªãƒ¼ ==="
                echo "Repo: ${env.REPO_OWNER}/${env.REPO_NAME}"
                echo "TestType: ${params.TEST_TYPE} / Action: ${params.ACTION}"
            }
        }
    }
}

// ---- ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•° ----

def shouldRun(String category) {
    return params.TEST_TYPE == 'ALL' || params.TEST_TYPE == category
}

def loadBaseline() {
    return readJSON text: env.BASELINE_CONFIG_JSON
}

def baseRepoConfig() {
    return [repoOwner: env.REPO_OWNER, repoName: env.REPO_NAME]
}

def cloneMap(Map src) {
    return src ? new groovy.json.JsonSlurperClassic().parseText(groovy.json.JsonOutput.toJson(src)) as Map : [:]
}

def filterBaselineForSmoke(Map baseline) {
    def filtered = [:]
    if (baseline.rulesets) { filtered.rulesets = baseline.rulesets.take(1) }
    if (baseline.branchProtection) { filtered.branchProtection = baseline.branchProtection }
    if (baseline.security) { filtered.security = baseline.security }
    if (baseline.labels) { filtered.labels = baseline.labels.take(3) }
    return filtered
}

// è¿½åŠ ãƒªãƒã‚¸ãƒˆãƒªæŒ‡å®šã‚’ owner/name ã®ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Š or JSONæ–‡å­—åˆ—ã‹ã‚‰ãƒªã‚¹ãƒˆã¸æ­£è¦åŒ–
def parseAdditionalRepos(String raw) {
    if (!raw?.trim()) { return [] }
    try {
        // JSONé…åˆ—ãŒæ¸¡ã•ã‚ŒãŸå ´åˆã‚’å„ªå…ˆ
        def parsed = new groovy.json.JsonSlurperClassic().parseText(raw)
        if (parsed instanceof List) { return parsed.collect { [owner: it.owner, name: it.name] } }
    } catch (Exception ignore) {
        // JSONã§ãªã‘ã‚Œã°ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã¨ã—ã¦å‡¦ç†
    }
    return raw.split(',').collect { item ->
        def parts = item.trim().split('/')
        if (parts.size() == 2) {
            return [owner: parts[0], name: parts[1]]
        }
        error "ADDITIONAL_REPOSã®å½¢å¼ãŒä¸æ­£ã§ã™: ${item}"
    }
}
