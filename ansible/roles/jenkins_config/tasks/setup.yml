---
# Jenkins設定タスク

# 設定開始前に既存のSSMドキュメントをクリーンアップ
- name: Display jenkins configuration information
  ansible.builtin.debug:
    msg: |
      Configuring Jenkins Controller:
      - Project: {{ project_name }}
      - Config Pulumi Project: {{ config_project_name }}
      - Environment: {{ env_name }}
      - Jenkins Instance ID: {{ jenkins_instance_id | default('未設定') }}
      - Jenkins Color: {{ jenkins_color | default('blue') }}

# 既存のSSMドキュメントを削除
- name: Destroy existing SSM documents with Pulumi
  ansible.builtin.include_role:
    name: pulumi_helper
    tasks_from: destroy
  vars:
    pulumi_project_path: "{{ pulumi_path }}/jenkins-config"
    target_resources:
      - "aws:ssm/document:Document {{ project_name }}-jenkins-update-repo"
      - "aws:ssm/document:Document {{ project_name }}-jenkins-install"
      - "aws:ssm/document:Document {{ project_name }}-jenkins-mount-efs"
      - "aws:ssm/document:Document {{ project_name }}-jenkins-configure"
      - "aws:ssm/document:Document {{ project_name }}-jenkins-startup"

# プレビュー用のタスクを実行する前に少し待機
- name: Wait for SSM documents to be fully deleted
  ansible.builtin.pause:
    seconds: 5

# コントローラースタックからJenkinsインスタンスIDを取得（未設定の場合）
- name: Get Jenkins instance ID from controller stack
  ansible.builtin.include_role:
    name: pulumi_helper
    tasks_from: get_outputs
  vars:
    pulumi_project_path: "{{ pulumi_path }}/jenkins-controller"
    output_name: "jenkinsInstanceId"
    mock_output: "mock-jenkins-instance-id"
  when: jenkins_instance_id is not defined or jenkins_instance_id == ""

- name: Set Jenkins instance ID from controller stack
  ansible.builtin.set_fact:
    jenkins_instance_id: "{{ stack_output_result.stdout | trim }}"
  when: 
    - jenkins_instance_id is not defined or jenkins_instance_id == ""
    - stack_output_result is defined and stack_output_result.stdout is defined

- name: Verify Jenkins instance ID
  ansible.builtin.fail:
    msg: "Unable to determine Jenkins instance ID. Please specify jenkins_instance_id or ensure controller is deployed."
  when: jenkins_instance_id is not defined or jenkins_instance_id == ""

- name: Display Jenkins instance ID
  ansible.builtin.debug:
    msg: "Using Jenkins Instance ID: {{ jenkins_instance_id }}"

# EFSファイルシステムIDの取得（未設定の場合）
- name: Get EFS file system ID from storage stack
  ansible.builtin.include_role:
    name: pulumi_helper
    tasks_from: get_outputs
  vars:
    pulumi_project_path: "{{ pulumi_path }}/jenkins-storage"
    output_name: "efsFileSystemId"
    mock_output: "mock-efs-id"
  when: efs_file_system_id is not defined or efs_file_system_id == ""

- name: Set EFS file system ID from storage stack
  ansible.builtin.set_fact:
    efs_file_system_id: "{{ stack_output_result.stdout | trim }}"
  when: efs_file_system_id is not defined or efs_file_system_id == ""

# ファイル権限設定
- name: Ensure aws-env.sh has execute permissions
  ansible.builtin.file:
    path: "{{ scripts_dir }}/aws-env.sh"
    mode: '0755'
  register: aws_env_script_permission
  no_log: true  # 詳細なログを抑制
  
- name: Report permission update
  ansible.builtin.debug:
    msg: "aws-env.sh スクリプトに実行権限を付与しました"
  when: aws_env_script_permission.changed

# 設定Pulumiスタックのデプロイ
- name: Deploy Jenkins Configuration with Pulumi
  block:
    # Pulumiヘルパータスクを呼び出す
    - name: Initialize config stack
      ansible.builtin.include_role:
        name: pulumi_helper
        tasks_from: init_stack
      vars:
        pulumi_project_path: "{{ pulumi_path }}/jenkins-config"
        stack_name: "{{ env_name }}"
    
    - name: Configure config stack
      ansible.builtin.shell: |
        cd {{ pulumi_path }}/jenkins-config
        source {{ scripts_dir }}/aws-env.sh > /dev/null 2>&1
        eval $({{ scripts_dir }}/aws-env.sh > /dev/null 2>&1)
        
        sudo -E /root/.pulumi/bin/pulumi config set aws:region {{ aws_region_name }}
        sudo -E /root/.pulumi/bin/pulumi config set {{ config_project_name }}:projectName {{ project_name }}
        sudo -E /root/.pulumi/bin/pulumi config set {{ config_project_name }}:jenkinsVersion {{ jenkins_version }}
        sudo -E /root/.pulumi/bin/pulumi config set {{ config_project_name }}:recoveryMode {{ recovery_mode | string | lower }}
      register: pulumi_config_result
      changed_when: pulumi_config_result.rc == 0
    
    # Pulumiプレビュー
    - name: Preview config deployment
      ansible.builtin.include_role:
        name: pulumi_helper
        tasks_from: preview
      vars:
        pulumi_project_path: "{{ pulumi_path }}/jenkins-config"
    
    # Pulumiデプロイ
    - name: Deploy config stack
      ansible.builtin.include_role:
        name: pulumi_helper
        tasks_from: deploy
      vars:
        pulumi_project_path: "{{ pulumi_path }}/jenkins-config"
    
    # デプロイ後に少し待機してスタックが完全に更新されるのを待つ
    - name: Wait for stack outputs to be available
      ansible.builtin.pause:
        seconds: 10
      when: not ansible_check_mode
    
    # SSMドキュメント名の取得
    - name: Get SSM document names
      ansible.builtin.include_role:
        name: pulumi_helper
        tasks_from: get_outputs
      vars:
        pulumi_project_path: "{{ pulumi_path }}/jenkins-config"
        output_name: "ssmDocuments"
        mock_output: '{\"install\":\"mock-install-doc\",\"mountEfs\":\"mock-mount-doc\",\"configure\":\"mock-config-doc\",\"startup\":\"mock-startup-doc\",\"updateRepo\":\"mock-update-repo-doc\"}'
    
    - name: Set SSM document names
      ansible.builtin.set_fact:
        ssm_documents: "{{ stack_output_result.stdout | from_json }}"
      
    - name: Display SSM document names
      ansible.builtin.debug:
        msg: |
          SSM Documents available:
          - Update Repo: {{ ssm_documents.updateRepo }}
          - Install: {{ ssm_documents.install }}
          - Mount EFS: {{ ssm_documents.mountEfs }}
          - Configure: {{ ssm_documents.configure }}
          - Startup: {{ ssm_documents.startup }}
  
  rescue:
    - name: Display error on config deployment
      ansible.builtin.debug:
        msg: "Failed to deploy Jenkins configuration resources. See error details above."
      
    - name: Fail the playbook
      ansible.builtin.fail:
        msg: "Jenkins configuration deployment failed."

# インスタンスの状態を直接確認
- name: Check instance basic information
  ansible.builtin.shell: |
    eval $({{ scripts_dir }}/aws-env.sh)
    aws ssm send-command \
      --region {{ aws_region_name }} \
      --document-name "AWS-RunShellScript" \
      --targets "Key=instanceids,Values={{ jenkins_instance_id }}" \
      --parameters 'commands=["echo Instance Info:","uname -a","cat /etc/os-release","echo","echo SSM Agent Status:","systemctl status amazon-ssm-agent | head -20","echo","echo Available Commands:","which yum","which mount","which systemctl","echo","echo Network:","ip addr show","echo","echo Disk:","df -h"]' \
      --output json 2>&1 | grep -v "^export"
  register: instance_check_command
  ignore_errors: true

- name: Wait for instance check to complete
  ansible.builtin.pause:
    seconds: 10
  when: instance_check_command.rc == 0

- name: Get instance check results
  ansible.builtin.shell: |
    eval $({{ scripts_dir }}/aws-env.sh)
    COMMAND_ID=$(echo '{{ instance_check_command.stdout }}' | grep -o '"CommandId": "[^"]*"' | cut -d'"' -f4 | head -1)
    if [ -n "$COMMAND_ID" ]; then
      aws ssm get-command-invocation \
        --region {{ aws_region_name }} \
        --command-id "$COMMAND_ID" \
        --instance-id "{{ jenkins_instance_id }}" \
        --query "StandardOutputContent" \
        --output text 2>&1 | grep -v "^export"
    fi
  register: instance_info
  when: instance_check_command.rc == 0
  ignore_errors: true

- name: Display instance information
  ansible.builtin.debug:
    msg: |
      Instance diagnostic information:
      {{ instance_info.stdout | default('Could not retrieve instance information') }}
  when: instance_info is defined

# SSMドキュメントの内容を確認
- name: Get SSM document content using AWS CLI
  ansible.builtin.shell: |
    eval $({{ scripts_dir }}/aws-env.sh)
    # First, check if the document exists
    aws ssm describe-document \
      --name "{{ ssm_documents.mountEfs }}" \
      --region {{ aws_region_name }} \
      --output json 2>&1 | grep -v "^export"
  register: doc_describe
  ignore_errors: true

- name: Get actual document content
  ansible.builtin.shell: |
    eval $({{ scripts_dir }}/aws-env.sh)
    aws ssm get-document \
      --name "{{ ssm_documents.mountEfs }}" \
      --region {{ aws_region_name }} \
      --document-version "\$DEFAULT" \
      --output json 2>&1 | grep -v "^export"
  register: doc_content
  when: doc_describe.rc == 0
  ignore_errors: true

- name: Display document information
  ansible.builtin.debug:
    msg: |
      Document description: {{ doc_describe.stdout | default('Not found') }}
      Document content: {{ doc_content.stdout | default('Not retrieved') }}
  when: doc_describe is defined

# Also check what's in the infrastructure-as-code repository
- name: Check repository contents for SSM documents
  ansible.builtin.shell: |
    eval $({{ scripts_dir }}/aws-env.sh)
    aws ssm send-command \
      --region {{ aws_region_name }} \
      --document-name "AWS-RunShellScript" \
      --targets "Key=instanceids,Values={{ jenkins_instance_id }}" \
      --parameters 'commands=["echo === Repository Contents ===","ls -la /opt/infrastructure-as-code/","echo === SSM Documents ===","find /opt/infrastructure-as-code -name \"*.yaml\" -o -name \"*.yml\" | grep -i ssm | head -10","echo === Mount EFS Script ===","find /opt/infrastructure-as-code -name \"*mount*efs*\" -type f | head -5"]' \
      --output json 2>&1 | grep -v "^export"
  register: repo_check
  ignore_errors: true

- name: Wait for repo check
  ansible.builtin.pause:
    seconds: 5
  when: repo_check.rc == 0

- name: Get repo check results
  ansible.builtin.shell: |
    eval $({{ scripts_dir }}/aws-env.sh)
    COMMAND_ID=$(echo '{{ repo_check.stdout | default("") }}' | grep -o '"CommandId": "[^"]*"' | cut -d'"' -f4 | head -1)
    if [ -n "$COMMAND_ID" ]; then
      aws ssm get-command-invocation \
        --region {{ aws_region_name }} \
        --command-id "$COMMAND_ID" \
        --instance-id "{{ jenkins_instance_id }}" \
        --query "StandardOutputContent" \
        --output text 2>&1 | grep -v "^export"
    fi
  register: repo_contents
  when: repo_check.rc == 0
  ignore_errors: true

- name: Display repository check results
  ansible.builtin.debug:
    msg: |
      Repository contents:
      {{ repo_contents.stdout | default('Could not check repository') }}
  when: repo_contents is defined

# ステップ1: Gitリポジトリの更新
- name: Step 1 - Update Git repository
  block:
    - name: Execute Git repository update SSM command
      ansible.builtin.shell: |
        eval $({{ scripts_dir }}/aws-env.sh)
        aws ssm send-command \
          --region {{ aws_region_name }} \
          --document-name "{{ ssm_documents.updateRepo }}" \
          --targets "Key=instanceids,Values={{ jenkins_instance_id }}" \
          --parameters "ProjectName={{ project_name }},Environment={{ env_name }},GitBranch={{ git_branch }},GitRepo={{ git_repo }}" \
          --comment "Updating Git repository" \
          --output json 2>&1 | grep -v "^export"
      register: git_update_command
      changed_when: true
      
    - name: Parse Git update command response
      ansible.builtin.set_fact:
        git_update_data: "{{ git_update_command.stdout | from_json }}"
      when: 
        - git_update_command.stdout is defined 
        - git_update_command.stdout != ''
        - git_update_command.rc == 0
      
    - name: Set Git update command ID from parsed data
      ansible.builtin.set_fact:
        git_update_command_id: "{{ git_update_data.Command.CommandId }}"
      when: 
        - git_update_data is defined 
        - git_update_data.Command is defined
        - git_update_data.Command.CommandId is defined
      
    - name: Display command ID
      ansible.builtin.debug:
        msg: "Git update command ID: {{ git_update_command_id | default('unknown') }}"
      
    - name: Wait for Git update command to complete
      ansible.builtin.shell: |
        eval $({{ scripts_dir }}/aws-env.sh)
        aws ssm list-commands \
          --region {{ aws_region_name }} \
          --command-id "{{ git_update_command_id }}" \
          --query "Commands[0].Status" \
          --output text 2>&1 | grep -v "^export"
      register: command_status_result
      until: command_status_result.stdout in ['Success', 'Failed', 'Cancelled', 'TimedOut']
      retries: 30
      delay: 10
      when: git_update_command_id is defined
      
    - name: Display command status
      ansible.builtin.debug:
        msg: "Command status: {{ command_status_result.stdout | default('Unknown') }}"
      
    - name: Fetch Git update command output
      ansible.builtin.shell: |
        eval $({{ scripts_dir }}/aws-env.sh)
        aws ssm get-command-invocation \
          --region {{ aws_region_name }} \
          --command-id "{{ git_update_command_id }}" \
          --instance-id "{{ jenkins_instance_id }}" \
          --output json 2>&1 | grep -v "^export"
      register: git_update_output_raw
      when: git_update_command_id is defined
      ignore_errors: true
      
    - name: Parse Git update command output
      ansible.builtin.set_fact:
        git_update_output: "{{ git_update_output_raw.stdout | from_json }}"
      when: 
        - git_update_output_raw is defined
        - git_update_output_raw.stdout is defined
        - git_update_output_raw.rc == 0
      
    - name: Display Git update output
      ansible.builtin.debug:
        msg: |
          Git repository update output:
          Standard Output: {{ git_update_output.StandardOutputContent | default('No output') }}
          Standard Error: {{ git_update_output.StandardErrorContent | default('No error') }}
      when: git_update_output is defined
      
    - name: Mark Git update as successful
      ansible.builtin.set_fact:
        git_update_complete: true
      when: 
        - command_status_result.stdout == 'Success'
        - git_update_output is defined
      
  rescue:
    - name: Mark Git update as failed
      ansible.builtin.set_fact:
        git_update_complete: false
      
    - name: Display Git update failure
      ansible.builtin.debug:
        msg: "Git repository update failed. Continuing with deployment..."
  
  always:
    - name: Ensure Git update status is set
      ansible.builtin.set_fact:
        git_update_complete: "{{ git_update_complete | default(false) }}"

# ステップ2: EFSマウント
- name: Step 2 - Mount EFS
  block:
    # まず簡単なテストコマンドを実行して、SSMが正常に動作するか確認
    # スクリプトの存在と内容を確認
    - name: Verify EFS mount script exists and check content
      ansible.builtin.shell: |
        eval $({{ scripts_dir }}/aws-env.sh)
        aws ssm send-command \
          --region {{ aws_region_name }} \
          --document-name "AWS-RunShellScript" \
          --targets "Key=instanceids,Values={{ jenkins_instance_id }}" \
          --parameters 'commands=["echo === Checking EFS mount script ===","ls -la /root/infrastructure-as-code/scripts/jenkins/shell/controller-mount-efs.sh","echo === Script content (first 50 lines) ===","head -50 /root/infrastructure-as-code/scripts/jenkins/shell/controller-mount-efs.sh","echo === Testing script syntax ===","bash -n /root/infrastructure-as-code/scripts/jenkins/shell/controller-mount-efs.sh && echo Script syntax is valid || echo Script has syntax errors"]' \
          --output json 2>&1 | grep -v "^export"
      register: script_verify
      ignore_errors: true
      
    - name: Wait for script verification
      ansible.builtin.pause:
        seconds: 5
      when: script_verify.rc == 0
      
    - name: Get script verification results
      ansible.builtin.shell: |
        eval $({{ scripts_dir }}/aws-env.sh)
        COMMAND_ID=$(echo '{{ script_verify.stdout }}' | grep -o '"CommandId": "[^"]*"' | cut -d'"' -f4 | head -1)
        if [ -n "$COMMAND_ID" ]; then
          aws ssm get-command-invocation \
            --region {{ aws_region_name }} \
            --command-id "$COMMAND_ID" \
            --instance-id "{{ jenkins_instance_id }}" \
            --query "StandardOutputContent" \
            --output text 2>&1 | grep -v "^export"
        fi
      register: script_content
      when: script_verify.rc == 0
      ignore_errors: true
      
    - name: Display script verification results
      ansible.builtin.debug:
        msg: |
          EFS mount script verification:
          {{ script_content.stdout | default('Could not verify script') }}
      when: script_content is defined

    # デバッグモードでスクリプトを実行
    - name: Execute EFS mount script with debug mode
      ansible.builtin.shell: |
        eval $({{ scripts_dir }}/aws-env.sh)
        aws ssm send-command \
          --region {{ aws_region_name }} \
          --document-name "AWS-RunShellScript" \
          --targets "Key=instanceids,Values={{ jenkins_instance_id }}" \
          --parameters 'commands=["#!/bin/bash -x","export PROJECT_NAME={{ project_name }}","export ENVIRONMENT={{ env_name }}","export EFS_ID={{ efs_file_system_id }}","export AWS_REGION={{ aws_region_name }}","echo Starting EFS mount process","cd /root/infrastructure-as-code","pwd","ls -la scripts/jenkins/shell/","echo Executing mount script with bash -x for debug","bash -x scripts/jenkins/shell/controller-mount-efs.sh 2>&1 | tee /tmp/efs-mount-debug.log","EXIT_CODE=$?","echo Exit code: $EXIT_CODE","echo === Debug output ===","cat /tmp/efs-mount-debug.log | tail -100","exit $EXIT_CODE"]' \
          --output json 2>&1 | grep -v "^export"
      register: debug_mount
      ignore_errors: true
      
    - name: Wait for debug mount execution
      ansible.builtin.pause:
        seconds: 10
      when: debug_mount.rc == 0
      
    - name: Get debug mount results
      ansible.builtin.shell: |
        eval $({{ scripts_dir }}/aws-env.sh)
        COMMAND_ID=$(echo '{{ debug_mount.stdout }}' | grep -o '"CommandId": "[^"]*"' | cut -d'"' -f4 | head -1)
        if [ -n "$COMMAND_ID" ]; then
          aws ssm get-command-invocation \
            --region {{ aws_region_name }} \
            --command-id "$COMMAND_ID" \
            --instance-id "{{ jenkins_instance_id }}" \
            --output json 2>&1 | grep -v "^export"
        fi
      register: debug_mount_results
      when: debug_mount.rc == 0
      ignore_errors: true
      
    - name: Display debug mount results
      ansible.builtin.debug:
        msg: |
          Debug mount execution results:
          {{ debug_mount_results.stdout | default('No debug results') }}
      when: debug_mount_results is defined

    # 手動でEFSマウントコマンドを実行してエラーを確認
    - name: Manually test EFS mount
      ansible.builtin.shell: |
        eval $({{ scripts_dir }}/aws-env.sh)
        aws ssm send-command \
          --region {{ aws_region_name }} \
          --document-name "AWS-RunShellScript" \
          --targets "Key=instanceids,Values={{ jenkins_instance_id }}" \
          --parameters 'commands=["echo === Manual EFS Mount Test ===","export PROJECT_NAME={{ project_name }}","export ENVIRONMENT={{ env_name }}","export EFS_ID={{ efs_file_system_id }}","export AWS_REGION={{ aws_region_name }}","echo Testing EFS DNS resolution","nslookup {{ efs_file_system_id }}.efs.{{ aws_region_name }}.amazonaws.com || echo DNS resolution failed","echo Creating mount point","mkdir -p /var/lib/jenkins","echo Testing EFS mount directly","mount -t efs -o tls {{ efs_file_system_id }}:/ /var/lib/jenkins || echo Direct mount failed","echo Checking if mounted","df -h | grep efs","echo Unmounting if mounted","umount /var/lib/jenkins 2>/dev/null || true"]' \
          --output json 2>&1 | grep -v "^export"
      register: manual_mount_test
      ignore_errors: true
      
    - name: Wait for manual mount test
      ansible.builtin.pause:
        seconds: 10
      when: manual_mount_test.rc == 0
      
    - name: Get manual mount test results
      ansible.builtin.shell: |
        eval $({{ scripts_dir }}/aws-env.sh)
        COMMAND_ID=$(echo '{{ manual_mount_test.stdout }}' | grep -o '"CommandId": "[^"]*"' | cut -d'"' -f4 | head -1)
        if [ -n "$COMMAND_ID" ]; then
          aws ssm get-command-invocation \
            --region {{ aws_region_name }} \
            --command-id "$COMMAND_ID" \
            --instance-id "{{ jenkins_instance_id }}" \
            --output json 2>&1 | grep -v "^export"
        fi
      register: manual_mount_results
      when: manual_mount_test.rc == 0
      ignore_errors: true
      
    - name: Display manual mount test results
      ansible.builtin.debug:
        msg: |
          Manual EFS mount test results:
          {{ manual_mount_results.stdout | default('No results') }}
      when: manual_mount_results is defined
      
    - name: Parse EFS mount command response
      ansible.builtin.set_fact:
        efs_mount_data: "{{ efs_mount_command.stdout | from_json }}"
      when: 
        - efs_mount_command.stdout is defined 
        - efs_mount_command.stdout != ''
        - efs_mount_command.rc == 0
      
    - name: Set EFS mount command ID from parsed data
      ansible.builtin.set_fact:
        efs_mount_command_id: "{{ efs_mount_data.Command.CommandId }}"
      when: 
        - efs_mount_data is defined 
        - efs_mount_data.Command is defined
        - efs_mount_data.Command.CommandId is defined
      
    - name: Display command ID
      ansible.builtin.debug:
        msg: "EFS mount command ID: {{ efs_mount_command_id | default('unknown') }}"
      
    - name: Wait for EFS mount command to complete
      ansible.builtin.shell: |
        eval $({{ scripts_dir }}/aws-env.sh)
        aws ssm list-commands \
          --region {{ aws_region_name }} \
          --command-id "{{ efs_mount_command_id }}" \
          --query "Commands[0].Status" \
          --output text 2>&1 | grep -v "^export"
      register: command_status_result
      until: command_status_result.stdout in ['Success', 'Failed', 'Cancelled', 'TimedOut']
      retries: 30
      delay: 10
      when: efs_mount_command_id is defined
      
    - name: Display command status
      ansible.builtin.debug:
        msg: "Command status: {{ command_status_result.stdout | default('Unknown') }}"
      
    - name: Fetch EFS mount command output
      ansible.builtin.shell: |
        eval $({{ scripts_dir }}/aws-env.sh)
        aws ssm get-command-invocation \
          --region {{ aws_region_name }} \
          --command-id "{{ efs_mount_command_id }}" \
          --instance-id "{{ jenkins_instance_id }}" \
          --output json 2>&1 | grep -v "^export"
      register: efs_mount_output_raw
      when: efs_mount_command_id is defined
      ignore_errors: true
      
    - name: Parse EFS mount command output
      ansible.builtin.set_fact:
        efs_mount_output: "{{ efs_mount_output_raw.stdout | from_json }}"
      when: 
        - efs_mount_output_raw is defined
        - efs_mount_output_raw.stdout is defined
        - efs_mount_output_raw.rc == 0
      
    - name: Display EFS mount output
      ansible.builtin.debug:
        msg: |
          EFS mount output:
          Status: {{ command_status_result.stdout }}
          Standard Output: {{ efs_mount_output.StandardOutputContent | default('No output') }}
          Standard Error: {{ efs_mount_output.StandardErrorContent | default('No error') }}
          Status Details: {{ efs_mount_output.StatusDetails | default('No details') }}
          Command ID: {{ efs_mount_command_id }}
      when: efs_mount_output is defined
      
    - name: Get detailed error from CloudWatch if command failed
      ansible.builtin.shell: |
        eval $({{ scripts_dir }}/aws-env.sh)
        aws ssm list-command-invocations \
          --command-id "{{ efs_mount_command_id }}" \
          --region {{ aws_region_name }} \
          --details \
          --output json 2>&1 | grep -v "^export"
      register: efs_mount_details
      when: 
        - efs_mount_command_id is defined
        - command_status_result.stdout == 'Failed'
      ignore_errors: true
      
    - name: Display detailed EFS mount error
      ansible.builtin.debug:
        msg: "Detailed error: {{ efs_mount_details.stdout | default('No details available') }}"
      when: efs_mount_details is defined
      
    - name: Get CloudWatch logs for EFS mount
      ansible.builtin.shell: |
        eval $({{ scripts_dir }}/aws-env.sh)
        # Get SSM agent logs directly from the instance
        aws ssm send-command \
          --region {{ aws_region_name }} \
          --document-name "AWS-RunShellScript" \
          --targets "Key=instanceids,Values={{ jenkins_instance_id }}" \
          --parameters 'commands=["echo === SSM Agent Logs ===","sudo tail -50 /var/log/amazon/ssm/amazon-ssm-agent.log | grep -A 10 -B 10 {{ efs_mount_command_id }} || echo No logs found for command","echo === Recent SSM Errors ===","sudo grep -i error /var/log/amazon/ssm/amazon-ssm-agent.log | tail -20","echo === Document Execution Logs ===","sudo ls -la /var/lib/amazon/ssm/{{ jenkins_instance_id }}/document/orchestration/{{ efs_mount_command_id }}/ || echo No execution logs found"]' \
          --output json 2>&1 | grep -v "^export"
      register: ssm_logs_command
      when: 
        - efs_mount_command_id is defined
        - command_status_result.stdout == 'Failed'
      ignore_errors: true
      
    - name: Wait for SSM logs command
      ansible.builtin.pause:
        seconds: 5
      when: ssm_logs_command is defined and ssm_logs_command.rc == 0
      
    - name: Get SSM logs results
      ansible.builtin.shell: |
        eval $({{ scripts_dir }}/aws-env.sh)
        COMMAND_ID=$(echo '{{ ssm_logs_command.stdout | default("") }}' | grep -o '"CommandId": "[^"]*"' | cut -d'"' -f4 | head -1)
        if [ -n "$COMMAND_ID" ]; then
          aws ssm get-command-invocation \
            --region {{ aws_region_name }} \
            --command-id "$COMMAND_ID" \
            --instance-id "{{ jenkins_instance_id }}" \
            --query "StandardOutputContent" \
            --output text 2>&1 | grep -v "^export"
        fi
      register: ssm_logs_output
      when: ssm_logs_command is defined and ssm_logs_command.rc == 0
      ignore_errors: true
      
    - name: Display SSM agent logs
      ansible.builtin.debug:
        msg: |
          SSM Agent logs related to EFS mount:
          {{ ssm_logs_output.stdout | default('No logs available') }}
      when: ssm_logs_output is defined
      
    - name: Mark EFS mount as successful
      ansible.builtin.set_fact:
        efs_mount_complete: true
      when: command_status_result.stdout == 'Success'
      
  rescue:
    - name: Mark EFS mount as failed
      ansible.builtin.set_fact:
        efs_mount_complete: false
      
    - name: Display EFS mount failure
      ansible.builtin.debug:
        msg: "EFS mount failed. Continuing with deployment..."
  
  always:
    - name: Ensure EFS mount status is set
      ansible.builtin.set_fact:
        efs_mount_complete: "{{ efs_mount_complete | default(false) }}"

# ステップ3: Jenkinsインストール
- name: Step 3 - Install Jenkins
  block:
    - name: Execute Jenkins install SSM command
      ansible.builtin.shell: |
        eval $({{ scripts_dir }}/aws-env.sh)
        aws ssm send-command \
          --region {{ aws_region_name }} \
          --document-name "{{ ssm_documents.install }}" \
          --targets "Key=instanceids,Values={{ jenkins_instance_id }}" \
          --parameters "ProjectName={{ project_name }},Environment={{ env_name }},JenkinsVersion={{ jenkins_version }},JenkinsColor={{ jenkins_color }}" \
          --comment "Installing Jenkins" \
          --output json 2>&1 | grep -v "^export"
      register: jenkins_install_command
      changed_when: true
      
    - name: Parse Jenkins install command response
      ansible.builtin.set_fact:
        jenkins_install_data: "{{ jenkins_install_command.stdout | from_json }}"
      when: 
        - jenkins_install_command.stdout is defined 
        - jenkins_install_command.stdout != ''
        - jenkins_install_command.rc == 0
      
    - name: Set Jenkins install command ID from parsed data
      ansible.builtin.set_fact:
        jenkins_install_command_id: "{{ jenkins_install_data.Command.CommandId }}"
      when: 
        - jenkins_install_data is defined 
        - jenkins_install_data.Command is defined
        - jenkins_install_data.Command.CommandId is defined
      
    - name: Display command ID
      ansible.builtin.debug:
        msg: "Jenkins install command ID: {{ jenkins_install_command_id | default('unknown') }}"
      
    - name: Wait for Jenkins install command to complete
      ansible.builtin.shell: |
        eval $({{ scripts_dir }}/aws-env.sh)
        aws ssm list-commands \
          --region {{ aws_region_name }} \
          --command-id "{{ jenkins_install_command_id }}" \
          --query "Commands[0].Status" \
          --output text 2>&1 | grep -v "^export"
      register: command_status_result
      until: command_status_result.stdout in ['Success', 'Failed', 'Cancelled', 'TimedOut']
      retries: 30
      delay: 10
      when: jenkins_install_command_id is defined
      
    - name: Display command status
      ansible.builtin.debug:
        msg: "Command status: {{ command_status_result.stdout | default('Unknown') }}"
      
    - name: Fetch Jenkins install command output
      ansible.builtin.shell: |
        eval $({{ scripts_dir }}/aws-env.sh)
        aws ssm get-command-invocation \
          --region {{ aws_region_name }} \
          --command-id "{{ jenkins_install_command_id }}" \
          --instance-id "{{ jenkins_instance_id }}" \
          --output json 2>&1 | grep -v "^export"
      register: jenkins_install_output_raw
      when: jenkins_install_command_id is defined
      ignore_errors: true
      
    - name: Parse Jenkins install command output
      ansible.builtin.set_fact:
        jenkins_install_output: "{{ jenkins_install_output_raw.stdout | from_json }}"
      when: 
        - jenkins_install_output_raw is defined
        - jenkins_install_output_raw.stdout is defined
        - jenkins_install_output_raw.rc == 0
      
    - name: Display Jenkins install output
      ansible.builtin.debug:
        msg: |
          Jenkins installation output:
          Status: {{ command_status_result.stdout }}
          Standard Output: {{ jenkins_install_output.StandardOutputContent | default('No output') }}
          Standard Error: {{ jenkins_install_output.StandardErrorContent | default('No error') }}
          Status Details: {{ jenkins_install_output.StatusDetails | default('No details') }}
      when: jenkins_install_output is defined
      
    - name: Mark Jenkins install as successful
      ansible.builtin.set_fact:
        jenkins_install_complete: true
      when: command_status_result.stdout == 'Success'
      
  rescue:
    - name: Mark Jenkins install as failed
      ansible.builtin.set_fact:
        jenkins_install_complete: false
      
    - name: Display Jenkins install failure
      ansible.builtin.debug:
        msg: "Jenkins installation failed. Continuing with deployment..."
  
  always:
    - name: Ensure Jenkins install status is set
      ansible.builtin.set_fact:
        jenkins_install_complete: "{{ jenkins_install_complete | default(false) }}"

# ステップ4: Jenkins設定
- name: Step 4 - Configure Jenkins
  block:
    - name: Execute Jenkins configure SSM command
      ansible.builtin.shell: |
        eval $({{ scripts_dir }}/aws-env.sh)
        aws ssm send-command \
          --region {{ aws_region_name }} \
          --document-name "{{ ssm_documents.configure }}" \
          --targets "Key=instanceids,Values={{ jenkins_instance_id }}" \
          --parameters "ProjectName={{ project_name }},Environment={{ env_name }},JenkinsMode={{ recovery_mode | ternary('recovery', 'normal') }},JenkinsColor={{ jenkins_color }}" \
          --comment "Configuring Jenkins" \
          --output json 2>&1 | grep -v "^export"
      register: jenkins_configure_command
      changed_when: true
      
    - name: Parse Jenkins configure command response
      ansible.builtin.set_fact:
        jenkins_configure_data: "{{ jenkins_configure_command.stdout | from_json }}"
      when: 
        - jenkins_configure_command.stdout is defined 
        - jenkins_configure_command.stdout != ''
        - jenkins_configure_command.rc == 0
      
    - name: Set Jenkins configure command ID from parsed data
      ansible.builtin.set_fact:
        jenkins_configure_command_id: "{{ jenkins_configure_data.Command.CommandId }}"
      when: 
        - jenkins_configure_data is defined 
        - jenkins_configure_data.Command is defined
        - jenkins_configure_data.Command.CommandId is defined
      
    - name: Display command ID
      ansible.builtin.debug:
        msg: "Jenkins configure command ID: {{ jenkins_configure_command_id | default('unknown') }}"
      
    - name: Wait for Jenkins configure command to complete
      ansible.builtin.shell: |
        eval $({{ scripts_dir }}/aws-env.sh)
        aws ssm list-commands \
          --region {{ aws_region_name }} \
          --command-id "{{ jenkins_configure_command_id }}" \
          --query "Commands[0].Status" \
          --output text 2>&1 | grep -v "^export"
      register: command_status_result
      until: command_status_result.stdout in ['Success', 'Failed', 'Cancelled', 'TimedOut']
      retries: 30
      delay: 10
      when: jenkins_configure_command_id is defined
      
    - name: Display command status
      ansible.builtin.debug:
        msg: "Command status: {{ command_status_result.stdout | default('Unknown') }}"
      
    - name: Fetch Jenkins configure command output
      ansible.builtin.shell: |
        eval $({{ scripts_dir }}/aws-env.sh)
        aws ssm get-command-invocation \
          --region {{ aws_region_name }} \
          --command-id "{{ jenkins_configure_command_id }}" \
          --instance-id "{{ jenkins_instance_id }}" \
          --output json 2>&1 | grep -v "^export"
      register: jenkins_configure_output_raw
      when: jenkins_configure_command_id is defined
      ignore_errors: true
      
    - name: Parse Jenkins configure command output
      ansible.builtin.set_fact:
        jenkins_configure_output: "{{ jenkins_configure_output_raw.stdout | from_json }}"
      when: 
        - jenkins_configure_output_raw is defined
        - jenkins_configure_output_raw.stdout is defined
        - jenkins_configure_output_raw.rc == 0
      
    - name: Display Jenkins configure output
      ansible.builtin.debug:
        msg: |
          Jenkins configuration output:
          Status: {{ command_status_result.stdout }}
          Standard Output: {{ jenkins_configure_output.StandardOutputContent | default('No output') }}
          Standard Error: {{ jenkins_configure_output.StandardErrorContent | default('No error') }}
          Status Details: {{ jenkins_configure_output.StatusDetails | default('No details') }}
      when: jenkins_configure_output is defined
      
    - name: Mark Jenkins configure as successful
      ansible.builtin.set_fact:
        jenkins_configure_complete: true
      when: command_status_result.stdout == 'Success'
      
  rescue:
    - name: Mark Jenkins configure as failed
      ansible.builtin.set_fact:
        jenkins_configure_complete: false
      
    - name: Display Jenkins configure failure
      ansible.builtin.debug:
        msg: "Jenkins configuration failed. Continuing with deployment..."
  
  always:
    - name: Ensure Jenkins configure status is set
      ansible.builtin.set_fact:
        jenkins_configure_complete: "{{ jenkins_configure_complete | default(false) }}"

# ステップ5: Jenkins起動
- name: Step 5 - Start Jenkins
  block:
    - name: Execute Jenkins startup SSM command
      ansible.builtin.shell: |
        eval $({{ scripts_dir }}/aws-env.sh)
        aws ssm send-command \
          --region {{ aws_region_name }} \
          --document-name "{{ ssm_documents.startup }}" \
          --targets "Key=instanceids,Values={{ jenkins_instance_id }}" \
          --parameters "ProjectName={{ project_name }},Environment={{ env_name }},JenkinsColor={{ jenkins_color }}" \
          --comment "Starting Jenkins" \
          --output json 2>&1 | grep -v "^export"
      register: jenkins_startup_command
      changed_when: true
      
    - name: Parse Jenkins startup command response
      ansible.builtin.set_fact:
        jenkins_startup_data: "{{ jenkins_startup_command.stdout | from_json }}"
      when: 
        - jenkins_startup_command.stdout is defined 
        - jenkins_startup_command.stdout != ''
        - jenkins_startup_command.rc == 0
      
    - name: Set Jenkins startup command ID from parsed data
      ansible.builtin.set_fact:
        jenkins_startup_command_id: "{{ jenkins_startup_data.Command.CommandId }}"
      when: 
        - jenkins_startup_data is defined 
        - jenkins_startup_data.Command is defined
        - jenkins_startup_data.Command.CommandId is defined
      
    - name: Display command ID
      ansible.builtin.debug:
        msg: "Jenkins startup command ID: {{ jenkins_startup_command_id | default('unknown') }}"
      
    - name: Wait for Jenkins startup command to complete
      ansible.builtin.shell: |
        eval $({{ scripts_dir }}/aws-env.sh)
        aws ssm list-commands \
          --region {{ aws_region_name }} \
          --command-id "{{ jenkins_startup_command_id }}" \
          --query "Commands[0].Status" \
          --output text 2>&1 | grep -v "^export"
      register: command_status_result
      until: command_status_result.stdout in ['Success', 'Failed', 'Cancelled', 'TimedOut']
      retries: 30
      delay: 10
      when: jenkins_startup_command_id is defined
      
    - name: Display command status
      ansible.builtin.debug:
        msg: "Command status: {{ command_status_result.stdout | default('Unknown') }}"
      
    - name: Fetch Jenkins startup command output
      ansible.builtin.shell: |
        eval $({{ scripts_dir }}/aws-env.sh)
        aws ssm get-command-invocation \
          --region {{ aws_region_name }} \
          --command-id "{{ jenkins_startup_command_id }}" \
          --instance-id "{{ jenkins_instance_id }}" \
          --output json 2>&1 | grep -v "^export"
      register: jenkins_startup_output_raw
      when: jenkins_startup_command_id is defined
      ignore_errors: true
      
    - name: Parse Jenkins startup command output
      ansible.builtin.set_fact:
        jenkins_startup_output: "{{ jenkins_startup_output_raw.stdout | from_json }}"
      when: 
        - jenkins_startup_output_raw is defined
        - jenkins_startup_output_raw.stdout is defined
        - jenkins_startup_output_raw.rc == 0
      
    - name: Display Jenkins startup output
      ansible.builtin.debug:
        msg: |
          Jenkins startup output:
          Status: {{ command_status_result.stdout }}
          Standard Output: {{ jenkins_startup_output.StandardOutputContent | default('No output') }}
          Standard Error: {{ jenkins_startup_output.StandardErrorContent | default('No error') }}
          Status Details: {{ jenkins_startup_output.StatusDetails | default('No details') }}
      when: jenkins_startup_output is defined
      
    - name: Mark Jenkins startup as successful
      ansible.builtin.set_fact:
        jenkins_startup_complete: true
      when: command_status_result.stdout == 'Success'
      
  rescue:
    - name: Mark Jenkins startup as failed
      ansible.builtin.set_fact:
        jenkins_startup_complete: false
      
    - name: Display Jenkins startup failure
      ansible.builtin.debug:
        msg: "Jenkins startup failed. Continuing with deployment..."
  
  always:
    - name: Ensure Jenkins startup status is set
      ansible.builtin.set_fact:
        jenkins_startup_complete: "{{ jenkins_startup_complete | default(false) }}"

# 設定完了を示す変数設定
- name: Set config deployment status
  ansible.builtin.set_fact:
    config_deployed: true

# 設定結果のサマリー表示
- name: Display Jenkins setup completion status
  ansible.builtin.debug:
    msg: |
      Jenkins Setup Status:
      - Git Repository Update: {{ git_update_complete | ternary('Success', 'Failed') }}
      - EFS Mount: {{ efs_mount_complete | ternary('Success', 'Failed') }}
      - Jenkins Installation: {{ jenkins_install_complete | ternary('Success', 'Failed') }}
      - Jenkins Configuration: {{ jenkins_configure_complete | ternary('Success', 'Failed') }}
      - Jenkins Startup: {{ jenkins_startup_complete | ternary('Success', 'Failed') }}
      - Configuration Deployment: {{ config_deployed | ternary('Success', 'Failed') }}

# エラー時の詳細情報表示
- name: Display troubleshooting information on failures
  ansible.builtin.debug:
    msg: |
      Troubleshooting steps:
      1. Check SSM agent status on instance {{ jenkins_instance_id }}
      2. Verify IAM role permissions for SSM access
      3. Check instance connectivity and security groups
      4. Review SSM document definitions in AWS console
      5. Check CloudWatch logs for SSM command execution details
      
      To manually debug on the instance:
      - SSH to the instance and check:
        - SSM agent status: sudo systemctl status amazon-ssm-agent
        - SSM agent logs: sudo tail -f /var/log/amazon/ssm/amazon-ssm-agent.log
        - Check if EFS tools are installed: rpm -qa | grep -E 'nfs-utils|amazon-efs-utils'
        - Check if Jenkins is installed: rpm -qa | grep jenkins
        - Check system logs: sudo journalctl -xe
      
      Command IDs for manual investigation:
      - Git update: {{ git_update_command_id | default('N/A') }}
      - EFS mount: {{ efs_mount_command_id | default('N/A') }}
      - Jenkins install: {{ jenkins_install_command_id | default('N/A') }}
      - Jenkins configure: {{ jenkins_configure_command_id | default('N/A') }}
      - Jenkins startup: {{ jenkins_startup_command_id | default('N/A') }}
  when: not (git_update_complete and efs_mount_complete and jenkins_install_complete and jenkins_configure_complete and jenkins_startup_complete)
