# 詳細設計フェーズ - レビュープロンプト

## レビュー対象
設計書をクリティカルシンキングの観点からレビューしてください。

### 設計書
@.ai-workflow/issue-369/02_design/output/design.md

### 要件定義書（参考）
@.ai-workflow/issue-369/01_requirements/output/requirements.md

### GitHub Issue情報（参考）
## Issue概要

- **Issue番号**: #369
- **タイトル**: [FEATURE] AIワークフローv2: Issue URLから対象リポジトリを自動判定して実行
- **状態**: open
- **URL**: https://github.com/tielec/infrastructure-as-code/issues/369
- **ラベル**: なし

### 本文

# [FEATURE] AIワークフローv2: Issue URLから対象リポジトリを自動判定して実行

## 概要

現在、AIワークフローv2（TypeScript版）は `scripts/ai-workflow-v2/` が配置されているリポジトリ（`infrastructure-as-code`）のみを対象としています。

**Issue URLから対象リポジトリを自動的に判定**して、別のリポジトリに対してもワークフローを実行できるようにしたいです。

## 現状の実装

### Issue URL例

```
https://github.com/tielec/infrastructure-as-code/issues/305
https://github.com/tielec/my-app/issues/123
https://github.com/tielec/another-repo/issues/456
```

### 現在の対象リポジトリ決定方法

`scripts/ai-workflow-v2/src/main.ts:445-452` で現在のGitリポジトリルートを取得：

```typescript
async function getRepoRoot(): Promise<string> {
  const git = simpleGit(process.cwd());
  try {
    const root = await git.revparse(['--show-toplevel']);
    return root.trim();
  } catch {
    return process.cwd();
  }
}
```

→ 実行環境のリポジトリ（infrastructure-as-code）に固定される

### 問題点

- Issue URLが `https://github.com/tielec/my-app/issues/123` でも、`infrastructure-as-code` リポジトリが対象になる
- 別リポジトリのIssueを指定しても、実際には間違ったリポジトリが操作される

## 要望

### Issue URLから自動判定

```bash
# tielec/my-app リポジトリのIssueを指定
npm run start -- init --issue-url https://github.com/tielec/my-app/issues/123

# → 自動的に以下を判定
#   - GitHubリポジトリ: tielec/my-app
#   - ローカルパス: C:\Users\ytaka\TIELEC\development\my-app
#   - リモートURL: https://github.com/tielec/my-app.git
```

### ローカルパスの判定ロジック

#### オプション1: 環境変数で親ディレクトリを指定（推奨）

```bash
# 環境変数設定（Jenkinsfileで設定）
export REPOS_ROOT="C:\Users\ytaka\TIELEC\development"

# Issue URLから判定
# https://github.com/tielec/my-app/issues/123
# → repo_name = "my-app"
# → local_path = "$REPOS_ROOT/my-app"
#   = "C:\Users\ytaka\TIELEC\development\my-app"
```

#### オプション2: リポジトリ名からパスを探索

```typescript
function findRepoPath(repoName: string): string | null {
  /**
   * リポジトリ名からローカルパスを探索
   */
  // 候補パスをリストアップ
  const searchRoots = [
    path.join(os.homedir(), 'TIELEC', 'development'),
    path.join(os.homedir(), 'projects'),
    path.join(process.cwd(), '..'),
  ];

  for (const root of searchRoots) {
    const candidate = path.join(root, repoName);
    if (fs.existsSync(candidate) && fs.existsSync(path.join(candidate, '.git'))) {
      return candidate;
    }
  }

  return null;
}
```

#### オプション3: 存在しない場合は自動clone（オプション機能）

```bash
# ローカルに存在しない場合、自動的にclone
git clone https://github.com/tielec/my-app.git $REPOS_ROOT/my-app
```

## 実装案

### 1. Issue URLからリポジトリ情報を抽出

`scripts/ai-workflow-v2/src/main.ts:485-491` の `parseIssueNumber` を拡張：

```typescript
interface IssueInfo {
  owner: string;
  repo: string;
  issueNumber: number;
  repositoryName: string; // "owner/repo" 形式
}

function parseIssueUrl(issueUrl: string): IssueInfo {
  /**
   * Issue URLからリポジトリ情報を抽出
   *
   * @param issueUrl - GitHub Issue URL
   *   例: https://github.com/tielec/my-app/issues/123
   *
   * @returns IssueInfo:
   *   - owner: リポジトリオーナー（例: tielec）
   *   - repo: リポジトリ名（例: my-app）
   *   - issueNumber: Issue番号（例: 123）
   *   - repositoryName: owner/repo形式（例: tielec/my-app）
   */
  // URLをパース
  // https://github.com/tielec/my-app/issues/123
  const match = issueUrl.match(/github\.com\/([^\/]+)\/([^\/]+)\/issues\/(\d+)/);

  if (!match) {
    throw new Error(`Invalid GitHub Issue URL: ${issueUrl}`);
  }

  const [, owner, repo, issueNumberStr] = match;
  const issueNumber = Number.parseInt(issueNumberStr, 10);

  return {
    owner,
    repo,
    issueNumber,
    repositoryName: `${owner}/${repo}`,
  };
}
```

### 2. ローカルリポジトリパスを判定

```typescript
function resolveLocalRepoPath(repoName: string): string {
  /**
   * リポジトリ名からローカルパスを解決
   *
   * @param repoName - リポジトリ名（例: my-app）
   *
   * @returns ローカルリポジトリパス
   *
   * @throws Error リポジトリが見つからない場合
   */
  // 1. 環境変数 REPOS_ROOT が設定されている場合
  const reposRoot = process.env.REPOS_ROOT;
  if (reposRoot) {
    const candidate = path.join(reposRoot, repoName);
    if (fs.existsSync(candidate) && fs.existsSync(path.join(candidate, '.git'))) {
      return candidate;
    }
  }

  // 2. 候補パスを探索
  const searchRoots = [
    path.join(os.homedir(), 'TIELEC', 'development'),
    path.join(os.homedir(), 'projects'),
    path.join(process.cwd(), '..'),
  ];

  for (const root of searchRoots) {
    if (!fs.existsSync(root)) {
      continue;
    }

    const candidate = path.join(root, repoName);
    if (fs.existsSync(candidate) && fs.existsSync(path.join(candidate, '.git'))) {
      return candidate;
    }
  }

  // 3. 見つからない場合はエラー
  throw new Error(
    `Repository '${repoName}' not found. ` +
    `Please set REPOS_ROOT environment variable or clone the repository.`
  );
}
```

### 3. init コマンドを修正

`scripts/ai-workflow-v2/src/main.ts:142-203` の `handleInitCommand` を修正：

```typescript
async function handleInitCommand(issueUrl: string): Promise<void> {
  // Issue URLをパース
  let issueInfo: IssueInfo;
  try {
    issueInfo = parseIssueUrl(issueUrl);
  } catch (error) {
    console.error(`[ERROR] ${(error as Error).message}`);
    process.exit(1);
  }

  const { owner, repo, issueNumber, repositoryName } = issueInfo;

  // ローカルリポジトリパスを解決
  let repoRoot: string;
  try {
    repoRoot = resolveLocalRepoPath(repo);
    console.info(`[INFO] Target repository: ${repositoryName}`);
    console.info(`[INFO] Local path: ${repoRoot}`);
  } catch (error) {
    console.error(`[ERROR] ${(error as Error).message}`);
    process.exit(1);
  }

  // ワークフローディレクトリ作成（対象リポジトリ配下）
  const workflowDir = path.join(repoRoot, '.ai-workflow', `issue-${issueNumber}`);
  const metadataPath = path.join(workflowDir, 'metadata.json');
  const branchName = `ai-workflow/issue-${issueNumber}`;

  await ensureBranch(repoRoot, branchName, workflowDir);

  fs.ensureDirSync(workflowDir);

  if (fs.existsSync(metadataPath)) {
    console.info('[INFO] Workflow already exists. Migrating metadata schema if required...');
    const state = WorkflowState.load(metadataPath);
    const migrated = state.migrate();
    const metadataManager = new MetadataManager(metadataPath);
    metadataManager.data.branch_name = branchName;
    metadataManager.data.repository = repositoryName;
    metadataManager.data.target_repository = {
      path: repoRoot,
      github_name: repositoryName,
      remote_url: `https://github.com/${repositoryName}.git`,
      owner,
      repo,
    };
    metadataManager.save();
    console.info(
      migrated
        ? '[OK] Metadata schema updated successfully.'
        : '[INFO] Metadata schema already up to date.',
    );
    return;
  }

  console.info('[INFO] Creating metadata...');
  WorkflowState.createNew(
    metadataPath,
    String(issueNumber),
    issueUrl,
    `Issue #${issueNumber}`,
  );

  const metadataManager = new MetadataManager(metadataPath);

  metadataManager.data.branch_name = branchName;
  metadataManager.data.repository = repositoryName;
  metadataManager.data.target_repository = {
    path: repoRoot,
    github_name: repositoryName,
    remote_url: `https://github.com/${repositoryName}.git`,
    owner,
    repo,
  };
  metadataManager.save();

  const gitManager = new GitManager(repoRoot, metadataManager);
  console.info('[INFO] Committing metadata.json...');
  const commitResult = await gitManager.commitPhaseOutput('planning', 'completed', 'N/A');
  if (!commitResult.success) {
    throw new Error(`Git commit failed: ${commitResult.error ?? 'unknown error'}`);
  }
  console.info(
    `[OK] Commit ${commitResult.commit_hash ? commitResult.commit_hash.slice(0, 7) : ''} created.`,
  );

  console.info('[INFO] Pushing to remote...');
  const pushResult = await gitManager.pushToRemote();
  if (!pushResult.success) {
    throw new Error(`Git push failed: ${pushResult.error ?? 'unknown error'}`);
  }
  console.info('[OK] Push successful.');

  const githubToken = process.env.GITHUB_TOKEN ?? null;
  if (!githubToken) {
    console.warn('[WARNING] GITHUB_TOKEN not set. PR creation skipped.');
    console.info('[INFO] You can create a PR manually (e.g. gh pr create --draft).');
    return;
  }

  try {
    const githubClient = new GitHubClient(githubToken, repositoryName);
    const existingPr = await githubClient.checkExistingPr(branchName);
    if (existingPr) {
      console.warn(`[WARNING] PR already exists: ${existingPr.pr_url}`);
      metadataManager.data.pr_number = existingPr.pr_number;
      metadataManager.data.pr_url = existingPr.pr_url;
      metadataManager.save();
      return;
    }

    console.info('[INFO] Creating draft PR...');
    const prTitle = `[AI-Workflow] Issue #${issueNumber}`;
    const prBody = githubClient.generatePrBodyTemplate(issueNumber, branchName);
    const prResult = await githubClient.createPullRequest(
      prTitle,
      prBody,
      branchName,
      'main',
      true,
    );

    if (prResult.success) {
      console.info(`[OK] Draft PR created: ${prResult.pr_url}`);
      metadataManager.data.pr_number = prResult.pr_number ?? null;
      metadataManager.data.pr_url = prResult.pr_url ?? null;
      metadataManager.save();
    } else {
      console.warn(
        `[WARNING] PR creation failed: ${prResult.error ?? 'unknown error'}. Please create manually.`,
      );
    }
  } catch (error) {
    console.warn(`[WARNING] Failed to create PR automatically: ${(error as Error).message}`);
  }
}
```

### 4. execute コマンドでメタデータから読み込み

`scripts/ai-workflow-v2/src/main.ts:249-475` の `handleExecuteCommand` を修正：

```typescript
async function handleExecuteCommand(options: any): Promise<void> {
  const issueNumber = String(options.issue);
  const phaseOption: string = (options.phase ?? 'all').toLowerCase();
  const presetOption: string | undefined = options.preset;
  const skipDependencyCheck = Boolean(options.skipDependencyCheck);
  const ignoreDependencies = Boolean(options.ignoreDependencies);
  const forceReset = Boolean(options.forceReset);

  if (presetOption && phaseOption !== 'all') {
    console.error("[ERROR] Options '--preset' and '--phase' are mutually exclusive.");
    process.exit(1);
  }

  if (!phaseOption && !presetOption) {
    console.error("[ERROR] Either '--phase' or '--preset' must be specified.");
    process.exit(1);
  }

  if (skipDependencyCheck && ignoreDependencies) {
    console.error("[ERROR] Options '--skip-dependency-check' and '--ignore-dependencies' are mutually exclusive.");
    process.exit(1);
  }

  // メタデータからリポジトリ情報を取得
  const { repoRoot, metadataPath } = await findWorkflowMetadata(issueNumber);

  if (!fs.existsSync(metadataPath)) {
    console.error('Error: Workflow not found. Run init first.');
    process.exit(1);
  }

  let metadataManager = new MetadataManager(metadataPath);

  // メタデータから対象リポジトリ情報を取得
  const targetRepo = metadataManager.data.target_repository;
  if (targetRepo) {
    console.info(`[INFO] Target repository: ${targetRepo.github_name}`);
    console.info(`[INFO] Local path: ${targetRepo.path}`);
  } else {
    // 後方互換性: target_repositoryが存在しない場合は現在のリポジトリを使用
    console.warn('[WARNING] target_repository not found in metadata. Using current repository.');
  }

  // 以降、既存の実装と同じ
  // ただし、workingDir は targetRepo.path を使用
  const workingDir = targetRepo?.path ?? repoRoot;

  // ... (省略)
}
```

### 5. .ai-workflow ディレクトリの配置

**対象リポジトリ配下に配置**（推奨）

```
C:\Users\ytaka\TIELEC\development\my-app/
  .ai-workflow/
    issue-123/
      metadata.json
      00_planning/
      01_requirements/
      ...
  src/
  README.md
  .gitignore  # .ai-workflow を追加
```

メリット:
- 成果物と対象リポジトリが同じ場所にある
- リポジトリごとに独立して管理できる
- Git管理対象外（.gitignoreに追加）

## メタデータスキーマ拡張

`scripts/ai-workflow-v2/src/types.ts` に `target_repository` フィールドを追加：

```typescript
export interface TargetRepository {
  path: string;              // ローカルパス
  github_name: string;       // owner/repo形式
  remote_url: string;        // Git remote URL
  owner: string;             // リポジトリオーナー
  repo: string;              // リポジトリ名
}

export interface WorkflowData {
  issue_number: string;
  issue_url: string;
  issue_title: string;
  branch_name?: string;
  repository?: string;       // 既存フィールド（後方互換性）
  target_repository?: TargetRepository; // 新規フィールド
  phases: Record<PhaseName, PhaseMetadata>;
  external_documents?: Record<string, string>;
  // ... その他のフィールド
}
```

metadata.json 例：

```json
{
  "issue_number": "123",
  "issue_url": "https://github.com/tielec/my-app/issues/123",
  "target_repository": {
    "path": "C:\\Users\\ytaka\\TIELEC\\development\\my-app",
    "github_name": "tielec/my-app",
    "remote_url": "https://github.com/tielec/my-app.git",
    "owner": "tielec",
    "repo": "my-app"
  },
  "phases": { ... }
}
```

## 環境変数

### REPOS_ROOT（推奨）

```bash
# Bash/Zsh
export REPOS_ROOT="C:\Users\ytaka\TIELEC\development"

# Jenkins環境変数
environment {
    REPOS_ROOT = 'C:\Users\ytaka\TIELEC\development'
}
```

## 使用例

### Case 1: infrastructure-as-codeリポジトリのIssue（現在と同じ）

```bash
cd C:\Users\ytaka\TIELEC\development\infrastructure-as-code

npm run start -- init \
  --issue-url https://github.com/tielec/infrastructure-as-code/issues/305

# → 対象: infrastructure-as-code リポジトリ
# → ローカルパス: C:\Users\ytaka\TIELEC\development\infrastructure-as-code
```

### Case 2: 別リポジトリ（my-app）のIssue

```bash
cd C:\Users\ytaka\TIELEC\development\infrastructure-as-code

# my-appリポジトリのIssueを指定
npm run start -- init \
  --issue-url https://github.com/tielec/my-app/issues/123

# → 自動判定
#   - GitHubリポジトリ: tielec/my-app
#   - ローカルパス: C:\Users\ytaka\TIELEC\development\my-app
#   - .ai-workflowディレクトリ: C:\Users\ytaka\TIELEC\development\my-app/.ai-workflow/

# 実行
npm run start -- execute --phase all --issue 123

# → my-appリポジトリが対象になる
```

### Case 3: リポジトリが見つからない場合

```bash
npm run start -- init \
  --issue-url https://github.com/tielec/unknown-repo/issues/999

# → [ERROR] Repository 'unknown-repo' not found.
#          Please set REPOS_ROOT environment variable or clone the repository.
```

## メリット

1. **シンプル**: Issue URLを指定するだけで対象リポジトリを自動判定
2. **追加オプション不要**: `--target-repo-path` などのオプションが不要
3. **直感的**: Issueとリポジトリが自然に対応
4. **マルチリポジトリ対応**: 複数のリポジトリで並行実行可能

## TODO

- [ ] `parseIssueUrl()` 関数を実装
- [ ] `resolveLocalRepoPath()` 関数を実装
- [ ] `findWorkflowMetadata()` 関数を実装（execute時のメタデータ探索）
- [ ] `handleInitCommand()` を修正（Issue URLから自動判定）
- [ ] `handleExecuteCommand()` を修正（メタデータから読み込み）
- [ ] `types.ts` に `TargetRepository` 型を追加
- [ ] `metadata.json` スキーマに `target_repository` フィールドを追加
- [ ] `WorkflowState` のマイグレーション機能実装
- [ ] 対象リポジトリの .gitignore に .ai-workflow を追加（自動 or ガイド）
- [ ] Jenkinsfile の環境変数設定（REPOS_ROOT）
- [ ] ドキュメント更新（README.md、使用例）
- [ ] テストケース追加

## 関連ファイル

- `scripts/ai-workflow-v2/src/main.ts`
- `scripts/ai-workflow-v2/src/core/metadata-manager.ts`
- `scripts/ai-workflow-v2/src/core/workflow-state.ts`
- `scripts/ai-workflow-v2/src/core/claude-agent-client.ts`
- `scripts/ai-workflow-v2/src/core/git-manager.ts`
- `scripts/ai-workflow-v2/src/core/github-client.ts`
- `scripts/ai-workflow-v2/src/types.ts`
- `jenkins/jobs/pipeline/ai-workflow/ai-workflow-orchestrator/Jenkinsfile`


## 品質ゲート（Phase 2）

設計書は以下の品質ゲートをクリアする必要があります：

- [ ] **実装戦略の判断根拠が明記されている**
- [ ] **テスト戦略の判断根拠が明記されている**
- [ ] **既存コードへの影響範囲が分析されている**
- [ ] **変更が必要なファイルがリストアップされている**
- [ ] **設計が実装可能である**

## ⚠️ 重要: Planning Phaseチェックリストとの照合（必須）

### 1. Planning.mdの読み込み

以下のファイルを読み込んでください：
- @.ai-workflow/issue-369/00_planning/output/planning.md

### 2. 該当フェーズのチェックリストを抽出

Planning.mdから、現在のフェーズ（"### Phase 2:" または "## Phase 2:"）のセクションを見つけ、タスクチェックリストを抽出してください。

**注意**: チェックリストが見つからない場合は、このチェックをスキップしてください。

### 3. 設計内容との照合

設計書（design.md）と照合し、各タスクが完了しているかチェックしてください。

**完了の判定基準**:
- Task記載の設計項目が記述されているか
- Task記載の戦略判断が明記されているか
- サブタスクがすべて完了しているか

### 4. Planning.mdの更新

照合結果に基づき、planning.mdのチェックボックスを更新してください：

- 完了したタスク: `- [ ]` → `- [x]`
- 未完了のタスク: `- [ ]` のまま

**Editツールを使用**して、該当フェーズのセクションを更新してください。

### 5. レビュー判定への反映

- **すべてのタスクが完了**（全て `[x]`）: PASS または PASS_WITH_SUGGESTIONS
- **未完了タスクがある**（`[ ]` が残っている）: FAIL
  - レビューフィードバックに未完了タスクをリストアップ
  - 具体的に何が不足しているか説明

**例（FAIL時のフィードバック）**:
```
## Planning Phaseチェックリスト照合結果: FAIL

以下のタスクが未完了です：

- [ ] Task 2-2: テスト戦略の決定
  - 不足: テスト戦略の判断根拠が記載されていません
- [ ] Task 2-3: 影響範囲分析
  - 不足: 既存コードへの影響範囲が分析されていません

これらのタスクを完了してから再提出してください。
```

## レビュー姿勢

このレビューは「**80点で十分**」の原則に基づいて実施してください：

1. **完璧ではなく、十分を目指す**
   - 設計書が次フェーズ（テストシナリオ作成）に進める状態であれば合格
   - 細かい表現の改善は改善提案として記載（ブロッカーにしない）

2. **ブロッカーと改善提案を明確に区別**
   - ブロッカー: 次フェーズ（テストシナリオ）に進めない重大な問題
   - 改善提案: 次フェーズに進めるが、改善が望ましい事項

3. **実用的でバランスの取れた判断**
   - プロジェクトを前に進めることを最優先
   - 実装フェーズで対応可能な問題はブロッカーにしない

4. **建設的なフィードバック**
   - 「ダメ」ではなく「こうすればより良い」という表現
   - 具体的な改善案を提示

## レビュー観点

### 1. 戦略判断の妥当性（最重要）

**実装戦略（CREATE/EXTEND/REFACTOR）**:
- 判断根拠が具体的かつ論理的に記載されているか
- 要件定義書の内容と整合しているか
- 既存コードへの影響が適切に評価されているか

**テスト戦略（UNIT_ONLY/INTEGRATION_ONLY/BDD_ONLY/UNIT_INTEGRATION/UNIT_BDD/INTEGRATION_BDD/ALL）**:
- 判断根拠が具体的かつ論理的に記載されているか
- 機能の複雑度に見合ったテスト戦略か
- 要件定義の受け入れ基準と整合しているか

**テストコード戦略（EXTEND_TEST/CREATE_TEST/BOTH_TEST）**:
- 判断根拠が具体的かつ論理的に記載されているか
- 既存テストとの関係が明確か

### 2. 影響範囲分析の適切性

- 既存コードへの影響が網羅的に分析されているか
- 依存関係が正しく把握されているか
- マイグレーションの必要性が評価されているか

### 3. ファイルリストの完全性

- 新規作成ファイルがリストアップされているか
- 修正が必要な既存ファイルがリストアップされているか
- パスが具体的で実装可能か

### 4. 設計の実装可能性

- 設計が具体的で実装者が迷わないか
- 技術的に実装可能な設計か
- 既存プロジェクトの規約・パターンに準拠しているか

### 5. 要件との対応（トレーサビリティ）

- 要件定義書の各要件に対応する設計があるか
- 要件の漏れがないか

### 6. セキュリティ考慮

- セキュリティリスクが識別されているか
- 対策が具体的か

### 7. 非機能要件への対応

- パフォーマンス考慮があるか
- スケーラビリティ考慮があるか
- 保守性考慮があるか

## ブロッカー（BLOCKER）と改善提案（SUGGESTION）の区別

### ブロッカー（BLOCKER）: 次フェーズに進めない重大な問題

**ブロッカーの例**:
- 3つの戦略判断（実装・テスト・テストコード）のいずれかが欠落
- 判断根拠が記載されていない、または論理的に破綻している
- 変更ファイルリストが未記載
- 設計が実装不可能（技術的制約に違反）
- 既存システムを破壊する設計
- 重大なセキュリティリスクが未対策
- 要件との対応が不明確

### 改善提案（SUGGESTION）: 次フェーズに進めるが、改善が望ましい事項

**改善提案の例**:
- より良い設計パターンの提案
- パフォーマンス最適化の余地
- ドキュメントの充実（例: 図表追加）
- エッジケースの追加考慮
- より詳細な影響範囲分析
- セキュリティ対策の強化

## 出力フォーマット

以下の形式で出力してください：

```markdown
## 品質ゲート評価

- [x/  ] **実装戦略の判断根拠が明記されている**: PASS/FAIL - （コメント）
- [x/  ] **テスト戦略の判断根拠が明記されている**: PASS/FAIL - （コメント）
- [x/  ] **既存コードへの影響範囲が分析されている**: PASS/FAIL - （コメント）
- [x/  ] **変更が必要なファイルがリストアップされている**: PASS/FAIL - （コメント）
- [x/  ] **設計が実装可能である**: PASS/FAIL - （コメント）

## 詳細レビュー

### 1. 戦略判断の妥当性

**良好な点**:
- （具体的な良い点）

**懸念点**:
- （懸念があれば記載）

### 2. 影響範囲分析の適切性

**良好な点**:
- （具体的な良い点）

**懸念点**:
- （懸念があれば記載）

### 3. ファイルリストの完全性

**良好な点**:
- （具体的な良い点）

**懸念点**:
- （懸念があれば記載）

### 4. 設計の実装可能性

**良好な点**:
- （具体的な良い点）

**懸念点**:
- （懸念があれば記載）

### 5. 要件との対応

**良好な点**:
- （具体的な良い点）

**懸念点**:
- （懸念があれば記載）

### 6. セキュリティ考慮

**良好な点**:
- （具体的な良い点）

**改善の余地**:
- （改善提案があれば記載）

### 7. 非機能要件への対応

**良好な点**:
- （具体的な良い点）

**改善の余地**:
- （改善提案があれば記載）

## ブロッカー（BLOCKER）

**次フェーズに進めない重大な問題**

（ブロッカーがある場合のみ記載）
1. **（ブロッカー1のタイトル）**
   - 問題: （具体的な問題）
   - 影響: （次フェーズにどう影響するか）
   - 対策: （どう修正すべきか）

## 改善提案（SUGGESTION）

**次フェーズに進めるが、改善が望ましい事項**

（改善提案がある場合のみ記載）
1. **（提案1のタイトル）**
   - 現状: （現在の状態）
   - 提案: （こうすればより良い）
   - 効果: （改善による効果）

## 総合評価

（設計書全体の総合的な評価）

**主な強み**:
- （良い点をまとめる）

**主な改善提案**:
- （改善提案をまとめる）

（総括コメント）

---
**判定: PASS / PASS_WITH_SUGGESTIONS / FAIL**
```

## レビュー実施

上記フォーマットに従って、設計書のクリティカルシンキングレビューを実施してください。

## ⚠️ 重要: 判定の出力は必須

**レビュー結果の最後に、必ず以下のいずれかの形式で判定を出力してください：**

```
---
**判定: PASS**
```

または

```
---
**判定: PASS_WITH_SUGGESTIONS**
```

または

```
---
**判定: FAIL**
```

**この判定がないと、レビュー結果が正しく処理されません。必ず3つのいずれかの判定を、上記の正確な形式で明示的に出力してください。**
