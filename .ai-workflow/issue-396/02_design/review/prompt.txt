# 詳細設計フェーズ - レビュープロンプト

## レビュー対象
設計書をクリティカルシンキングの観点からレビューしてください。

### 設計書
@.ai-workflow/issue-396/02_design/output/design.md

### 要件定義書（参考）
@.ai-workflow/issue-396/01_requirements/output/requirements.md

### GitHub Issue情報（参考）
## Issue概要

- **Issue番号**: #396
- **タイトル**: [FEATURE] ai-workflow-v2: Preset機能の拡充による開発フロー最適化
- **状態**: open
- **URL**: https://github.com/tielec/infrastructure-as-code/issues/396
- **ラベル**: enhancement

### 本文

# [FEATURE] ai-workflow-v2: Preset機能の拡充による開発フロー最適化

## 概要

ai-workflow-v2には既に`--preset`オプションが実装されていますが、実際の開発パターンをカバーしきれていません。本Issueでは、実際の開発ワークフローを分析し、プリセット機能を拡充することで開発効率を向上させます。

## 現状の問題点

### 既存のプリセット (phase-dependencies.ts)

```typescript
export const PHASE_PRESETS: Record<string, PhaseName[]> = {
  'requirements-only': ['requirements'],
  'design-phase': ['requirements', 'design'],
  'implementation-phase': ['requirements', 'design', 'test_scenario', 'implementation'],
  'full-workflow': [全Phase],
};
```

### 問題点

#### 1. 命名の一貫性がない

- `requirements-only`: `-only` サフィックス
- `design-phase`: `-phase` サフィックス
- `implementation-phase`: `-phase` サフィックス
- `full-workflow`: `-workflow` サフィックス

→ **チーム内で混乱を招く**

#### 2. 実際の開発パターンをカバーしていない

| 開発シナリオ | 現在の対応 | 問題点 |
|------------|-----------|--------|
| **軽微な修正** (タイポ、小さなバグ) | `--phase all` で全Phase実行 | 8-12時間かかる。実装+ドキュメント+レポートだけで十分 |
| **テスト追加** | 個別に `--phase test_implementation`, `--phase testing` | 2回実行が必要 |
| **ドキュメント更新のみ** | `--phase documentation` | プリセットがないので分かりにくい |
| **レポート作成のみ** | `--phase report` | プリセットがないので分かりにくい |

#### 3. 依存関係が考慮されていない

- `requirements-only`: planningが含まれていない → 依存関係エラーの可能性
- `design-phase`: planningが含まれていない → 依存関係エラーの可能性

#### 4. プロンプトの依存関係問題

**現状**: 各フェーズのプロンプトは全Phase連続実行を前提として設計されている

**問題**:
- Phase 4（implementation）のみ実行 → requirements.md, design.md が存在しない
- プロンプト内で `{requirements_document_path}` が空文字列になる
- Agentが混乱する可能性

**プロンプト例** (implementation/execute.txt):
```markdown
### 要件定義書
{requirements_document_path}

### 設計書
{design_document_path}

### テストシナリオ
{test_scenario_document_path}
```

→ これらのファイルが存在しない場合、プロンプトが不完全になる

## 実際の開発ワークフローパターン

### パターン1: レビュー駆動開発

**シナリオ**: 各フェーズでPRレビューを受けながら進める

| パターン | 実行Phase | 用途 |
|---------|----------|------|
| 要件定義レビュー | Planning → Requirements | 要件定義のみ作成してレビュー待ち |
| 設計レビュー | Planning → Requirements → Design | 設計まで作成してレビュー待ち |
| テストシナリオレビュー | Planning → Requirements → Design → TestScenario | テストシナリオまで作成してレビュー待ち |

### パターン2: 実装中心のワークフロー

**シナリオ**: 要件が明確で、実装から開始

| パターン | 実行方法 | 用途 |
|---------|---------|------|
| 軽微な修正 | `--preset quick-fix` | タイポ修正、小さなバグ修正 |
| 通常の実装 | `--preset implementation` | 実装+テスト+ドキュメント |
| 実装のみ | `--phase implementation` | 後でテスト追加予定（単一Phase） |

### パターン3: テスト中心のワークフロー

**シナリオ**: 実装済み、テストを追加

| パターン | 実行方法 | 用途 |
|---------|---------|------|
| テスト追加 | `--preset testing` | テストコード追加+実行 |
| テスト実行のみ | `--phase testing` | テスト実行のみ（単一Phase） |

### パターン4: ドキュメント・レポート作成

**シナリオ**: 実装完了、ドキュメント作成のみ

| パターン | 実行方法 | 用途 |
|---------|---------|------|
| ドキュメント更新のみ | `--phase documentation` | ドキュメント更新のみ（単一Phase） |
| レポート作成のみ | `--phase report` | レポート作成のみ（単一Phase） |
| 最終化 | `--preset finalize` | ドキュメント+レポート+評価 |

### パターン5: フルワークフロー

**シナリオ**: 新規Issue、全フェーズ実行

| パターン | 実行方法 | 用途 |
|---------|---------|------|
| 全フェーズ | `--phase all` | 新規Issue、全フェーズ実行（Planning → ... → Evaluation） |

**注**: プリセットではなく `--phase all` を使用（既存機能で十分カバーされている）

## 提案: 新しいプリセット設計

### 設計原則

1. **命名規則の統一**
   - 用途を表す名詞を使用
   - カテゴリごとにサフィックスを統一

2. **依存関係の明示的な管理**
   - 各プリセットは依存関係を考慮したPhaseリストとする
   - planningが必要なプリセットには必ずplanningを含める

3. **実用性重視**
   - 実際の開発パターンから逆算してプリセットを定義
   - 頻度の高いパターンを優先

4. **拡張性**
   - カテゴリごとに整理し、将来的な追加が容易

### 提案するプリセット一覧

```typescript
export const PHASE_PRESETS: Record<string, PhaseName[]> = {
  // === レビュー駆動パターン ===
  'review-requirements': ['planning', 'requirements'],
  'review-design': ['planning', 'requirements', 'design'],
  'review-test-scenario': ['planning', 'requirements', 'design', 'test_scenario'],

  // === 実装中心パターン ===
  'quick-fix': ['implementation', 'documentation', 'report'],
  'implementation': ['implementation', 'test_implementation', 'testing', 'documentation', 'report'],

  // === テスト中心パターン ===
  'testing': ['test_implementation', 'testing'],

  // === ドキュメント・レポートパターン ===
  'finalize': ['documentation', 'report', 'evaluation'],
};
```

**設計方針**:
- **プリセット**: 複数Phaseの組み合わせのみ（7個）
- **単一Phase実行**: `--phase <name>` を使用
  - 例: `--phase implementation`, `--phase documentation`, `--phase testing`, `--phase report`

### 使用例

#### レビュー駆動開発

```bash
# Step 1: 要件定義を作成してレビュー待ち
npm run start -- execute --issue 123 --preset review-requirements

# レビュー承認後、Step 2: 設計を追加
npm run start -- execute --issue 123 --preset review-design

# レビュー承認後、Step 3: テストシナリオを追加
npm run start -- execute --issue 123 --preset review-test-scenario

# レビュー承認後、実装フェーズに移行
npm run start -- execute --issue 123 --preset implementation
```

#### 軽微な修正

```bash
# タイポ修正、小さなバグ修正
npm run start -- execute --issue 123 --preset quick-fix

# 実行されるPhase:
#   - Phase 4: Implementation
#   - Phase 7: Documentation
#   - Phase 8: Report
# 所要時間: 2-3時間（全Phase実行の8-12時間から大幅短縮）
```

#### 通常の実装フロー

```bash
# 実装 + テスト + ドキュメント + レポート
npm run start -- execute --issue 123 --preset implementation

# 実行されるPhase:
#   - Phase 4: Implementation
#   - Phase 5: TestImplementation
#   - Phase 6: Testing
#   - Phase 7: Documentation
#   - Phase 8: Report
```

#### テスト追加

```bash
# 既存実装にテストを追加
npm run start -- execute --issue 123 --preset testing

# 実行されるPhase:
#   - Phase 5: TestImplementation
#   - Phase 6: Testing
```

#### 単一Phase実行（プリセット不要）

```bash
# 実装のみ
npm run start -- execute --issue 123 --phase implementation

# ドキュメント更新のみ
npm run start -- execute --issue 123 --phase documentation

# テスト実行のみ
npm run start -- execute --issue 123 --phase testing

# レポート作成のみ
npm run start -- execute --issue 123 --phase report
```

**注意**: 単一Phase実行時は、依存関係チェックとプロンプトのオプショナル参照が重要

#### 全フェーズ実行

```bash
# 新規Issue、全フェーズ実行
npm run start -- execute --issue 123 --phase all

# Resume機能により、中断したフェーズから自動再開される
```

## プロンプト改善と依存関係チェック強化

### 課題1: プロンプトの依存関係問題

現在のプロンプトは前段Phaseの成果物を必須参照として扱っているため、単一Phase実行やプリセット実行時に問題が発生します。

**例1**: `quick-fix` プリセット実行時
- Phase 4（implementation）のみ実行
- requirements.md, design.md, test-scenario.md が存在しない
- プロンプト内で `{requirements_document_path}` が空文字列になる

**例2**: `--phase implementation` で単一Phase実行時
- 同様に前段Phaseの成果物が存在しない可能性がある
- プロンプトが不完全になる

### 課題2: 依存関係チェックの確認

**現在の実装確認が必要**:

`phase-dependencies.ts` には `validatePhaseDependencies` 関数が実装されていますが、以下を確認する必要があります：

1. **単一Phase実行時に依存関係チェックが動作するか**
   - `--phase implementation` 実行時、planning/requirements/design/test_scenarioの完了チェックは行われるか？
   - チェックが失敗した場合、エラーで停止するか、警告のみか？

2. **依存関係チェックの厳格性**
   - `skipDependencyCheck` オプションの使用状況
   - `ignoreViolations` オプションの使用状況
   - デフォルトの動作は厳格か、緩いか？

3. **メタデータとファイル存在の整合性**
   - metadata.jsonで `completed` となっていても、実際のファイルが存在しない場合は？
   - ファイル存在チェックも行うべきか？

### 解決策: オプショナル参照への変更

#### 改善前: implementation/execute.txt（必須参照）

```markdown
## 参照ドキュメント

### 要件定義書
{requirements_document_path}

### 設計書
{design_document_path}

### テストシナリオ
{test_scenario_document_path}

上記のドキュメントに基づいて実装してください。
```

**問題点**:
- ファイルが存在しない場合、変数が空文字列になる
- プロンプトが不完全になる

#### 改善後: implementation/execute.txt（オプショナル参照）

```markdown
## 参照ドキュメント

### Issue情報（必須）
{issue_info}

### Planning情報（必須）
{planning_document_path}

### 要件定義書（利用可能な場合）
{requirements_context}
<!--
  存在する場合: @requirements.md への参照
  存在しない場合: "要件定義書は利用できません。Planning情報とIssue情報から要件を推測してください。"
-->

### 設計書（利用可能な場合）
{design_context}
<!--
  存在する場合: @design.md への参照
  存在しない場合: "設計書は利用できません。Issue情報とPlanning情報に基づいて適切な設計判断を行ってください。"
-->

### テストシナリオ（利用可能な場合）
{test_scenario_context}
<!--
  存在する場合: @test-scenario.md への参照
  存在しない場合: "テストシナリオは利用できません。実装時に適切なテスト考慮を行ってください。"
-->

## 実装指示

上記の利用可能なドキュメントとIssue情報に基づいて実装してください。
ドキュメントが利用できない場合は、Issue情報とPlanning情報から合理的に判断してください。
```

### TypeScriptでの実装

```typescript
// src/phases/implementation.ts (execute メソッド)

function buildOptionalContext(
  filename: string,
  issueNumber: number,
  fallbackMessage: string
): string {
  const filePath = getPhaseOutputFile(filename, issueNumber);

  if (filePath && fs.existsSync(filePath)) {
    return `@${filePath}`;
  } else {
    return fallbackMessage;
  }
}

// プロンプトのコンテキスト構築
const context = {
  issue_info: getIssueInfo(issueNumber),
  planning_document_path: getPlanningDocumentPath(issueNumber), // 必須

  // オプショナルコンテキスト
  requirements_context: buildOptionalContext(
    'requirements.md',
    issueNumber,
    '要件定義書は利用できません。Planning情報とIssue情報から要件を推測してください。'
  ),

  design_context: buildOptionalContext(
    'design.md',
    issueNumber,
    '設計書は利用できません。Issue情報とPlanning情報に基づいて適切な設計判断を行ってください。'
  ),

  test_scenario_context: buildOptionalContext(
    'test-scenario.md',
    issueNumber,
    'テストシナリオは利用できません。実装時に適切なテスト考慮を行ってください。'
  ),
};
```

### プロンプト修正対象

- [ ] `implementation/execute.txt`
- [ ] `test_implementation/execute.txt`
- [ ] `testing/execute.txt`
- [ ] `documentation/execute.txt`
- [ ] `report/execute.txt` (全Phaseの成果物を参照するため、特に重要)

## 実装計画

### Phase 1: 既存プリセットの整理（優先度: High）

**見積もり**: 2-3時間

**実装内容**:
1. 既存プリセット名を新しい命名規則に変更
   - `requirements-only` → `review-requirements`
   - `design-phase` → `review-design`
   - `implementation-phase` → `implementation`
   - `full-workflow` → **削除**（`--phase all` で代替）

2. 依存関係を考慮したPhaseリストに修正
   - `review-requirements`: planningを追加
   - `review-design`: planningを追加

3. 後方互換性のため、古いプリセット名もエイリアスとして残す（deprecation warning付き）
   - `full-workflow` のみ、明示的に「`--phase all` を使用してください」というメッセージを表示

**修正ファイル**:
- `src/core/phase-dependencies.ts`

**成果物**:
- 既存プリセットが新しい命名規則に準拠
- 依存関係エラーが解消される

### Phase 2: 新規プリセットの追加（優先度: High）

**見積もり**: 3-4時間

**実装内容**:
1. 頻度の高い**複数Phaseプリセット**を追加
   - `quick-fix`: 軽微な修正用
   - `testing`: テスト追加用
   - `finalize`: 最終化用
   - `review-test-scenario`: テストシナリオレビュー用

2. 単一Phaseプリセットは**追加しない**（`--phase <name>` で十分）
   - ❌ `code-only` → `--phase implementation` を使用
   - ❌ `test-only` → `--phase testing` を使用
   - ❌ `docs` → `--phase documentation` を使用
   - ❌ `report-only` → `--phase report` を使用

3. プリセット一覧の取得コマンド追加
   ```bash
   npm run start -- execute --list-presets
   ```

**修正ファイル**:
- `src/core/phase-dependencies.ts`
- `src/main.ts` (--list-presets オプション追加)

**成果物**:
- 実際の開発パターンをカバーする7個のプリセット（複数Phaseの組み合わせのみ）
- プリセット一覧表示機能

### Phase 3: 依存関係チェック確認とプロンプト改善（優先度: High）

**見積もり**: 6-8時間

**実装内容**:

#### 3-1. 依存関係チェックの確認と強化（2-3時間）

1. **現在の実装を確認**
   - `--phase implementation` 実行時の依存関係チェック動作を検証
   - `validatePhaseDependencies` の呼び出しタイミングを確認
   - `skipDependencyCheck`, `ignoreViolations` オプションの使用状況を確認

2. **依存関係チェックの強化（必要に応じて）**
   - 単一Phase実行時に依存関係チェックを必ず実行
   - デフォルトは厳格モード（依存Phase未完了時はエラーで停止）
   - `--ignore-dependencies` オプションで緩和可能（警告のみ）
   - ファイル存在チェックも追加（metadata.json と実ファイルの整合性）

3. **エラーメッセージの改善**
   ```
   [ERROR] Phase "implementation" requires the following phases to be completed:
     ✗ planning - .ai-workflow/issue-123/00_planning/output/planning.md NOT FOUND
     ✗ requirements - .ai-workflow/issue-123/01_requirements/output/requirements.md NOT FOUND

   Options:
     1. Complete the missing phases first
     2. Use --phase all to run all phases
     3. Use --ignore-dependencies to proceed anyway (not recommended)
   ```

#### 3-2. プロンプトのオプショナル参照対応（3-5時間）

1. `buildOptionalContext` ヘルパー関数の実装
2. 各PhaseのbaseクラスでgetPhaseOutputFileメソッドを共通化
3. 各Phase executeメソッドでオプショナルコンテキスト構築
4. プロンプトファイルの修正

**修正ファイル**:

**依存関係チェック関連**:
- `src/main.ts` (依存関係チェック強化、エラーメッセージ改善)
- `src/core/phase-dependencies.ts` (ファイル存在チェック追加)
- `src/phases/base-phase.ts` (共通チェックロジック)

**プロンプト改善関連**:
- `src/phases/base-phase.ts` (buildOptionalContext追加)
- `src/phases/implementation.ts`
- `src/phases/test-implementation.ts`
- `src/phases/testing.ts`
- `src/phases/documentation.ts`
- `src/phases/report.ts`
- `src/prompts/implementation/execute.txt`
- `src/prompts/test_implementation/execute.txt`
- `src/prompts/testing/execute.txt`
- `src/prompts/documentation/execute.txt`
- `src/prompts/report/execute.txt`

**成果物**:
- 単一Phase実行時の依存関係チェックが正常に動作する
- 依存Phaseが未完了の場合、明確なエラーメッセージと選択肢を表示
- プリセット実行時に前段Phaseの成果物が存在しなくても動作する（`--ignore-dependencies` 使用時）
- Agentが適切なフォールバック動作を行う

### Phase 4: ドキュメント更新（優先度: Medium）

**見積もり**: 2-3時間

**実装内容**:
1. README.mdにプリセット一覧セクションを追加
2. 各プリセットの用途と使用例を記載
3. プリセット vs --phase の使い分けガイド
4. 移行ガイド（古いプリセット名 → 新しいプリセット名）

**修正ファイル**:
- `README.md`

**成果物**:
- プリセット機能の利用ガイド
- チーム内での標準化促進

### Phase 5: テストとバリデーション（優先度: Medium）

**見積もり**: 2-3時間

**実装内容**:
1. 各プリセットの動作テスト
2. 依存関係チェックのテスト
3. オプショナル参照のテスト
4. エラーケースのテスト

**テストケース**:

**プリセット実行テスト**:
- [ ] `quick-fix` プリセット実行（前段Phaseなし、`--ignore-dependencies` 必要）
- [ ] `review-requirements` プリセット実行
- [ ] `implementation` プリセット実行
- [ ] `testing` プリセット実行
- [ ] 存在しないプリセット名でエラー
- [ ] 古いプリセット名 (`requirements-only`, `design-phase`, `implementation-phase`) で deprecation warning
- [ ] `full-workflow` プリセット実行時に「`--phase all` を使用してください」メッセージ

**依存関係チェックテスト**:
- [ ] `--phase implementation` 実行時、依存Phase未完了でエラー
- [ ] `--phase implementation --ignore-dependencies` 実行時、警告のみで実行
- [ ] 依存Phase完了時、正常に実行
- [ ] metadata.json に `completed` だがファイルが存在しない場合のエラー処理

**プロンプトオプショナル参照テスト**:
- [ ] requirements.md 不在時、フォールバックメッセージが表示される
- [ ] design.md 不在時、フォールバックメッセージが表示される
- [ ] Agent が適切に動作する（エラーにならない）

**成果物**:
- 全プリセットの動作確認完了
- 依存関係チェックの動作確認完了
- バグ修正

## 期待される効果

### 1. 開発効率の大幅向上

| シナリオ | 現在 | 改善後 | 削減時間 |
|---------|------|--------|---------|
| 軽微な修正 | `--phase all` (8-12h) | `--preset quick-fix` (2-3h) | **6-9h削減** |
| テスト追加 | 個別実行 x 2回 | `--preset testing` x 1回 | 操作の簡略化 |
| ドキュメント更新 | `--phase documentation` | `--preset docs` | 明確化 |
| レビュー駆動開発 | 不明瞭 | `--preset review-*` | 標準化 |

### 2. チーム内の開発フロー標準化

- ✅ ベストプラクティスがプリセットに組み込まれる
- ✅ 開発フローが統一される
- ✅ 新メンバーのオンボーディングが容易

### 3. 柔軟性の確保

- ✅ プリセットでカバーされないパターンは `--phase <name>` で対応
- ✅ 段階的な拡張が可能（新しいプリセットを追加しやすい）

### 4. プロンプトの堅牢性向上

- ✅ 前段Phaseの成果物が存在しなくても動作する
- ✅ Agentが混乱せず、適切なフォールバック動作を行う

## オプションの使い分けガイド

### `--preset`: 定義済みのワークフローパターン（推奨）

**用途**: よく使うパターンを簡単に実行

```bash
npm run start -- execute --issue 123 --preset quick-fix
npm run start -- execute --issue 123 --preset implementation
```

**メリット**:
- ✅ 簡潔で覚えやすい
- ✅ ベストプラクティスが組み込まれている
- ✅ チーム内で統一された開発フロー

### `--phase`: 単一フェーズまたは全フェーズ

**用途**: 特定のフェーズのみ実行、またはデバッグ

```bash
npm run start -- execute --issue 123 --phase implementation
npm run start -- execute --issue 123 --phase all
```

**メリット**:
- ✅ 柔軟性が高い
- ✅ デバッグ・テスト時に便利

**依存関係チェック**:
- デフォルト: 依存Phase未完了時はエラーで停止
- `--ignore-dependencies` オプションで警告のみに緩和可能（非推奨）

```bash
# 依存関係を無視して実行（非推奨）
npm run start -- execute --issue 123 --phase implementation --ignore-dependencies
```

**推奨**: 複数Phaseの実行にはプリセットを使用

## 移行ガイド

### 既存プリセット名から新プリセット名への移行

| 古いプリセット名 | 新プリセット名 | 変更内容 |
|----------------|--------------|---------|
| `requirements-only` | `review-requirements` | planningを追加 |
| `design-phase` | `review-design` | planningを追加 |
| `implementation-phase` | `implementation` | 変更なし |
| `full-workflow` | **削除** | `--phase all` を使用 |

**移行期間**: 旧プリセット名は deprecation warning 付きで6ヶ月間サポート

**注**: `full-workflow` は `--phase all` で代替可能なため、プリセットとしては削除

## 関連Issue

- #382: Review agentにPlanning.mdチェックリスト照合機能を追加

## 見積もり合計

| Phase | 優先度 | 見積もり | 内容 |
|-------|-------|---------|------|
| Phase 1: 既存プリセット整理 | High | 2-3h | 命名変更、依存関係修正、後方互換性 |
| Phase 2: 新規プリセット追加 | High | 3-4h | 7個のプリセット追加、一覧表示機能 |
| Phase 3: 依存関係チェック + プロンプト改善 | High | 6-8h | 依存関係確認・強化、オプショナル参照 |
| Phase 4: ドキュメント更新 | Medium | 2-3h | README更新、使い分けガイド |
| Phase 5: テスト・検証 | Medium | 2-3h | 全プリセット、依存関係、プロンプトテスト |
| **合計** | - | **15-21h** | |

**最小実装（Phase 1-3）**: 11-15時間
- 既存プリセット整理 + 新規プリセット追加 + 依存関係チェック + プロンプト改善
- これだけで主要な効果が得られる

**重要**: Phase 3の「依存関係チェックの確認」は、現在の実装状況により見積もりが変動する可能性があります。


## 品質ゲート（Phase 2）

設計書は以下の品質ゲートをクリアする必要があります：

- [ ] **実装戦略の判断根拠が明記されている**
- [ ] **テスト戦略の判断根拠が明記されている**
- [ ] **既存コードへの影響範囲が分析されている**
- [ ] **変更が必要なファイルがリストアップされている**
- [ ] **設計が実装可能である**

## ⚠️ 重要: Planning Phaseチェックリストとの照合（必須）

### 1. Planning.mdの読み込み

以下のファイルを読み込んでください：
- @.ai-workflow/issue-396/00_planning/output/planning.md

### 2. 該当フェーズのチェックリストを抽出

Planning.mdから、現在のフェーズ（"### Phase 2:" または "## Phase 2:"）のセクションを見つけ、タスクチェックリストを抽出してください。

**注意**: チェックリストが見つからない場合は、このチェックをスキップしてください。

### 3. 設計内容との照合

設計書（design.md）と照合し、各タスクが完了しているかチェックしてください。

**完了の判定基準**:
- Task記載の設計項目が記述されているか
- Task記載の戦略判断が明記されているか
- サブタスクがすべて完了しているか

### 4. Planning.mdの更新

照合結果に基づき、planning.mdのチェックボックスを更新してください：

- 完了したタスク: `- [ ]` → `- [x]`
- 未完了のタスク: `- [ ]` のまま

**Editツールを使用**して、該当フェーズのセクションを更新してください。

### 5. レビュー判定への反映

- **すべてのタスクが完了**（全て `[x]`）: PASS または PASS_WITH_SUGGESTIONS
- **未完了タスクがある**（`[ ]` が残っている）: FAIL
  - レビューフィードバックに未完了タスクをリストアップ
  - 具体的に何が不足しているか説明

**例（FAIL時のフィードバック）**:
```
## Planning Phaseチェックリスト照合結果: FAIL

以下のタスクが未完了です：

- [ ] Task 2-2: テスト戦略の決定
  - 不足: テスト戦略の判断根拠が記載されていません
- [ ] Task 2-3: 影響範囲分析
  - 不足: 既存コードへの影響範囲が分析されていません

これらのタスクを完了してから再提出してください。
```

## レビュー姿勢

このレビューは「**80点で十分**」の原則に基づいて実施してください：

1. **完璧ではなく、十分を目指す**
   - 設計書が次フェーズ（テストシナリオ作成）に進める状態であれば合格
   - 細かい表現の改善は改善提案として記載（ブロッカーにしない）

2. **ブロッカーと改善提案を明確に区別**
   - ブロッカー: 次フェーズ（テストシナリオ）に進めない重大な問題
   - 改善提案: 次フェーズに進めるが、改善が望ましい事項

3. **実用的でバランスの取れた判断**
   - プロジェクトを前に進めることを最優先
   - 実装フェーズで対応可能な問題はブロッカーにしない

4. **建設的なフィードバック**
   - 「ダメ」ではなく「こうすればより良い」という表現
   - 具体的な改善案を提示

## レビュー観点

### 1. 戦略判断の妥当性（最重要）

**実装戦略（CREATE/EXTEND/REFACTOR）**:
- 判断根拠が具体的かつ論理的に記載されているか
- 要件定義書の内容と整合しているか
- 既存コードへの影響が適切に評価されているか

**テスト戦略（UNIT_ONLY/INTEGRATION_ONLY/BDD_ONLY/UNIT_INTEGRATION/UNIT_BDD/INTEGRATION_BDD/ALL）**:
- 判断根拠が具体的かつ論理的に記載されているか
- 機能の複雑度に見合ったテスト戦略か
- 要件定義の受け入れ基準と整合しているか

**テストコード戦略（EXTEND_TEST/CREATE_TEST/BOTH_TEST）**:
- 判断根拠が具体的かつ論理的に記載されているか
- 既存テストとの関係が明確か

### 2. 影響範囲分析の適切性

- 既存コードへの影響が網羅的に分析されているか
- 依存関係が正しく把握されているか
- マイグレーションの必要性が評価されているか

### 3. ファイルリストの完全性

- 新規作成ファイルがリストアップされているか
- 修正が必要な既存ファイルがリストアップされているか
- パスが具体的で実装可能か

### 4. 設計の実装可能性

- 設計が具体的で実装者が迷わないか
- 技術的に実装可能な設計か
- 既存プロジェクトの規約・パターンに準拠しているか

### 5. 要件との対応（トレーサビリティ）

- 要件定義書の各要件に対応する設計があるか
- 要件の漏れがないか

### 6. セキュリティ考慮

- セキュリティリスクが識別されているか
- 対策が具体的か

### 7. 非機能要件への対応

- パフォーマンス考慮があるか
- スケーラビリティ考慮があるか
- 保守性考慮があるか

## ブロッカー（BLOCKER）と改善提案（SUGGESTION）の区別

### ブロッカー（BLOCKER）: 次フェーズに進めない重大な問題

**ブロッカーの例**:
- 3つの戦略判断（実装・テスト・テストコード）のいずれかが欠落
- 判断根拠が記載されていない、または論理的に破綻している
- 変更ファイルリストが未記載
- 設計が実装不可能（技術的制約に違反）
- 既存システムを破壊する設計
- 重大なセキュリティリスクが未対策
- 要件との対応が不明確

### 改善提案（SUGGESTION）: 次フェーズに進めるが、改善が望ましい事項

**改善提案の例**:
- より良い設計パターンの提案
- パフォーマンス最適化の余地
- ドキュメントの充実（例: 図表追加）
- エッジケースの追加考慮
- より詳細な影響範囲分析
- セキュリティ対策の強化

## 出力フォーマット

以下の形式で出力してください：

```markdown
## 品質ゲート評価

- [x/  ] **実装戦略の判断根拠が明記されている**: PASS/FAIL - （コメント）
- [x/  ] **テスト戦略の判断根拠が明記されている**: PASS/FAIL - （コメント）
- [x/  ] **既存コードへの影響範囲が分析されている**: PASS/FAIL - （コメント）
- [x/  ] **変更が必要なファイルがリストアップされている**: PASS/FAIL - （コメント）
- [x/  ] **設計が実装可能である**: PASS/FAIL - （コメント）

## 詳細レビュー

### 1. 戦略判断の妥当性

**良好な点**:
- （具体的な良い点）

**懸念点**:
- （懸念があれば記載）

### 2. 影響範囲分析の適切性

**良好な点**:
- （具体的な良い点）

**懸念点**:
- （懸念があれば記載）

### 3. ファイルリストの完全性

**良好な点**:
- （具体的な良い点）

**懸念点**:
- （懸念があれば記載）

### 4. 設計の実装可能性

**良好な点**:
- （具体的な良い点）

**懸念点**:
- （懸念があれば記載）

### 5. 要件との対応

**良好な点**:
- （具体的な良い点）

**懸念点**:
- （懸念があれば記載）

### 6. セキュリティ考慮

**良好な点**:
- （具体的な良い点）

**改善の余地**:
- （改善提案があれば記載）

### 7. 非機能要件への対応

**良好な点**:
- （具体的な良い点）

**改善の余地**:
- （改善提案があれば記載）

## ブロッカー（BLOCKER）

**次フェーズに進めない重大な問題**

（ブロッカーがある場合のみ記載）
1. **（ブロッカー1のタイトル）**
   - 問題: （具体的な問題）
   - 影響: （次フェーズにどう影響するか）
   - 対策: （どう修正すべきか）

## 改善提案（SUGGESTION）

**次フェーズに進めるが、改善が望ましい事項**

（改善提案がある場合のみ記載）
1. **（提案1のタイトル）**
   - 現状: （現在の状態）
   - 提案: （こうすればより良い）
   - 効果: （改善による効果）

## 総合評価

（設計書全体の総合的な評価）

**主な強み**:
- （良い点をまとめる）

**主な改善提案**:
- （改善提案をまとめる）

（総括コメント）

---
**判定: PASS / PASS_WITH_SUGGESTIONS / FAIL**
```

## レビュー実施

上記フォーマットに従って、設計書のクリティカルシンキングレビューを実施してください。

## ⚠️ 重要: 判定の出力は必須

**レビュー結果の最後に、必ず以下のいずれかの形式で判定を出力してください：**

```
---
**判定: PASS**
```

または

```
---
**判定: PASS_WITH_SUGGESTIONS**
```

または

```
---
**判定: FAIL**
```

**この判定がないと、レビュー結果が正しく処理されません。必ず3つのいずれかの判定を、上記の正確な形式で明示的に出力してください。**
